<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨二小</title>
  <subtitle>Machine repeats,Human creates.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zerosoul.github.io/"/>
  <updated>2017-03-31T02:46:18.000Z</updated>
  <id>http://zerosoul.github.io/</id>
  
  <author>
    <name>杨二小</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>你可能不知道的Safari 10.1(iOS 10.3)Web开发新特性</title>
    <link href="http://zerosoul.github.io/2017/03/31/new-web-features-in-safari-10-1/"/>
    <id>http://zerosoul.github.io/2017/03/31/new-web-features-in-safari-10-1/</id>
    <published>2017-03-31T01:29:24.000Z</published>
    <updated>2017-03-31T02:46:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="qiaobusi.jpg" alt="乔布斯与HTML5"></p>
<p>伴随着 iOS 10.3 和 macOS Sierra 10.12.4 的更新，一个新版本的Safari也随之而来，其中有许多值得一提的web新特性让前端工程师激动不已，恩，值得唠唠。</p>
<p>这次新版本的发布不仅让web更为强大，同时也简化了当前代码的维护，使得web开发更得心应手。前端工程师利用这些改进能够给用户带来更好的体验，想想都有些小激动呢。</p>
<p>好了，废话不多说，下面看看都有哪些新特性：</p>
<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>Fetch是<code>XMLHttpRequest</code>的改进版本。它能够以更简洁的方式异步获取资源，不仅如此，它还利用ECMAScript 2015(ES6)中的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects" target="_blank" rel="external">Promises</a>,简化和链式响应操作。相对于<code>XMLHttpRequest</code>，Fetch API更简洁，更具有可读性，从而也就更易维护。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonURLEndpoint = <span class="string">"https://svn.webkit.org/repository/webkit/trunk/Source/WebCore/features.json"</span>;</div><div class="line">fetch(jsonURLEndpoint, &#123;</div><div class="line">    method: <span class="string">"get"</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">    response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(json);</div><div class="line">    &#125;);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>想了解更多请参考：<a href="https://fetch.spec.whatwg.org/" target="_blank" rel="external">Fetch标准</a></p>
<h1 id="CSS栅格-CSS-Grid-Layout"><a href="#CSS栅格-CSS-Grid-Layout" class="headerlink" title="CSS栅格(CSS Grid Layout)"></a>CSS栅格(CSS Grid Layout)</h1><p>CSS栅格基于容器的行与列，给前端工程师带来一种强大的新布局方式。通过CSS提供的这种可控的页面布局工具，可以针对不同视口做出复杂的平面排版设计。以前利用CSS中的奇淫技巧才能实现的打印样式，像浮动和Flexbox，现在可以通过CSS栅格轻松实现。</p>
<p>想了解更多请参考：<a href="https://webkit.org/blog/7434/css-grid-layout-a-new-layout-module-for-the-web/" target="_blank" rel="external">CSS栅格系统: 一种新的布局方式</a></p>
<h1 id="ECMAScript-2016-amp-ECMAScript-2017"><a href="#ECMAScript-2016-amp-ECMAScript-2017" class="headerlink" title="ECMAScript 2016 &amp; ECMAScript 2017"></a>ECMAScript 2016 &amp; ECMAScript 2017</h1><p>ECMAScript 2016 和 ECMAScript 2017是Javascript的最新语言标准，Safari 10.1新增了一些支持。当然，对ECMAScript 2016只是做了些微小的工作，毕竟2016版的标准由来已久，但2017版的标准却带来了不小的改进。</p>
<p><a href="https://www.ecma-international.org/ecma-262/7.0/" target="_blank" rel="external">ECMAScript 2016</a>带来的改进包括：</p>
<ul>
<li>求幂运算符（<code>x ** y</code>可以替代<code>Math.pow(x,y)</code>，更简洁了！）</li>
<li><code>Array.prototype.includes</code>（与<code>Array.prototype.indexOf</code>类似，只不过能对<code>NaN</code>做出识别）</li>
</ul>
<p><a href="https://tc39.github.io/ecma262/" target="_blank" rel="external">ECMAScript 2017</a>带来了:</p>
<ul>
<li><code>async</code>和<code>await</code>语法，</li>
<li>共享内存对象，包括原子类型（Atomics）和（缓冲数组）Shared Array Buffers</li>
<li><code>String.prototype.padStart</code>,<code>String.prototype.padEnd</code>,<code>String.prototype.values</code>和<code>String.prototype.entries</code></li>
<li>允许在函数参数列表和调用中使用逗号</li>
</ul>
<h1 id="IndexDB-2-0"><a href="#IndexDB-2-0" class="headerlink" title="IndexDB 2.0"></a>IndexDB 2.0</h1><p>新版本的IndexDB有了更大的提升。它更快，与标准更兼容，并且支持IndexDB 2.0的新特性。IndexedDB 2.0加入了对二进制数据的支持，比如索引键，这样就不用再将其序列化为字符串或者对象数组。不仅如此，还有对象存储和索引重命名，<code>IDBObjectStore</code>的<code>getKey()</code>和<code>IDBIndex</code>的<code>getPrimaryKey()</code>。</p>
<p>想了解更多请参考文档：<a href="https://www.w3.org/TR/IndexedDB-2/" target="_blank" rel="external">Indexed Database API 2.0</a></p>
<h1 id="自定义元素-Custom-Elements"><a href="#自定义元素-Custom-Elements" class="headerlink" title="自定义元素(Custom Elements)"></a>自定义元素(Custom Elements)</h1><p>前端工程师不用再依赖Javascript框架来创建可复用组件啦，自定义元素可以轻松做到。和那些内置元素一样，自定义元素也可以通过特性（attributes）设置和获取值，并且还可以通过回调函数响应用户的交互。</p>
<p>了解更多请参考：<a href="https://webkit.org/blog/7027/introducing-custom-elements/" target="_blank" rel="external">自定义元素简介</a></p>
<h1 id="游戏手柄（Gamepad）"><a href="#游戏手柄（Gamepad）" class="headerlink" title="游戏手柄（Gamepad）"></a>游戏手柄（Gamepad）</h1><p>Gamepad API 让Web App使用游戏手柄成为可能。在macOS中任何无需通过额外驱动就可以使用的游戏手柄，Web App都可以完美兼容，当然，iOS中的MFi游戏手柄也同样支持。</p>
<p>了解更多请参考：<a href="https://www.w3.org/TR/gamepad/" target="_blank" rel="external">Gamepad规范</a></p>
<h1 id="指针锁"><a href="#指针锁" class="headerlink" title="指针锁"></a>指针锁</h1><p>macOS中的Safari通过在元素中使用指针锁，可以让鼠标指针隐藏，同时还可以获取鼠标移动的数据。这个在开发Web游戏中特别有用。指针锁还扩展了<code>MouseEvents</code>接口，新增了<code>movementX</code>和<code>movementY</code>两个属性，即使鼠标移出了可视区域，依然能获取流信息。鼠标锁于某个元素时，Safari还会显示提示栏通知用户鼠标指针已隐藏。第一次按<code>ESC</code>键，会关闭提示栏，再次按<code>ESC</code>，将会释放指针锁。</p>
<p>更多信息请移步：<a href="https://www.w3.org/TR/pointerlock/" target="_blank" rel="external">Pointer Lock 规范</a></p>
<h1 id="全屏下的键盘输入"><a href="#全屏下的键盘输入" class="headerlink" title="全屏下的键盘输入"></a>全屏下的键盘输入</h1><p>WebKit通常会限制在全屏模式下的键盘输入，随着macOS Safari 10.1的更新，这一限制已去掉。</p>
<h1 id="交互式的表单验证"><a href="#交互式的表单验证" class="headerlink" title="交互式的表单验证"></a>交互式的表单验证</h1><p>在旧浏览器时代，你知道我指的是哪一款o(╯□╰)o，表单验证一直是件头痛的事情，后来HTML5引入了一些表单元素的特性，解决了一些常见的验证需求，比如必填，约束数据类型等。Safari 10.1更进一步，引入了<code>checkValidity()</code>和<code>reportValidity()</code>两个扩展接口，让提示更标准化，大大减少了Javascript代码。</p>
<p>了解更多：<a href="https://webkit.org/blog/7099/html-interactive-form-validation/" target="_blank" rel="external">HTML交互式表单验证</a></p>
<h1 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a>输入事件</h1><p>输入事件简化了富文本输入的实现。新增的<code>beforeinput</code>监听并截获默认的输入行为，并通过新特性强化了该事件。</p>
<p>了解更多：<a href="https://webkit.org/blog/7358/enhanced-editing-with-input-events/" target="_blank" rel="external">使用输入事件增强编辑体验</a></p>
<h1 id="HTML5的下载特性"><a href="#HTML5的下载特性" class="headerlink" title="HTML5的下载特性"></a>HTML5的下载特性</h1><p><code>a</code>标签中的<code>download</code>特性标识了是个可下载的链接，用户点击后往往会直接下载资源而非跳转新页面。不仅如此，前端工程师也可以完全使用Javascript来创建blob数据当做文件资源来下载。如果<code>download</code>指定了值，那么就相当于重命名了下载文件的名字。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://webkit.org/favicon.ico"</span> <span class="attr">download</span>=<span class="string">"webkit-favicon.ico"</span>&gt;</span>Download Favicon<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>了解更多：<a href="https://html.spec.whatwg.org/multipage/semantics.html#downloading-resources" target="_blank" rel="external">HTML5中下载资源</a></p>
<h1 id="HTML媒体捕捉"><a href="#HTML媒体捕捉" class="headerlink" title="HTML媒体捕捉"></a>HTML媒体捕捉</h1><p>在新版的Safari中，HTML媒体捕捉扩展了其捕捉类型，可以使用设备上的相机和麦克来获取用户输入。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"imageCapture"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span> <span class="attr">capture</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"videoCapture"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"video/*"</span> <span class="attr">capture</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"audioCapture"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"audio/*"</span> <span class="attr">capture</span>&gt;</span>`</div></pre></td></tr></table></figure>
<p>更多细节请移步：<a href="https://www.w3.org/TR/html-media-capture/" target="_blank" rel="external">HTML媒体捕捉</a></p>
<h1 id="改进了fixed和sticky元素的定位"><a href="#改进了fixed和sticky元素的定位" class="headerlink" title="改进了fixed和sticky元素的定位"></a>改进了<code>fixed</code>和<code>sticky</code>元素的定位</h1><p>当捏合放大（pinch-to-zoom）时，固定和粘连元素的定位表现有了提升，这得归功于<strong>视觉窗口</strong>(visual viewports)。有了视觉窗口，输入元素获取焦点时不再会禁用固定和粘连元素的定位了。</p>
<h1 id="改进的Web调试"><a href="#改进的Web调试" class="headerlink" title="改进的Web调试"></a>改进的Web调试</h1><p>WebKit新增了针对Web Worker的调试支持，同时对正在调试和即将执行的语句高亮，这样，就能清楚看出哪条代码即将执行，在一些控制流程非常复杂或者多条语句写在了一行中，这种改进的体验非常棒。</p>
<p>更详细的介绍请移步：<a href="https://webkit.org/blog/7219/javascript-debugging-improvements/" target="_blank" rel="external">Javascript调试改进</a></p>
<h1 id="CSS全范围色彩（Wide-Gamut-Colors）"><a href="#CSS全范围色彩（Wide-Gamut-Colors）" class="headerlink" title="CSS全范围色彩（Wide-Gamut Colors）"></a>CSS全范围色彩（Wide-Gamut Colors）</h1><p>现在的设备能够支持色域更广的颜色。随着新版本Safari的发行，前端工程师能够扩展出更多的色彩想象力，包括Display P3色彩域。通过<code>color-gamut</code>媒体查询可以测试出显示器是否支持该特性，然后用CSS新增的<code>color()</code>函数，定义出新的颜色。</p>
<pre><code class="CSS">@<span class="keyword">media</span> (color-gamut:p3) {
    <span class="selector-class">.brightred</span> {
        <span class="attribute">color</span>: <span class="built_in">color</span>(display-p3 1.0 0 0);
    }
}
</code></pre>
<p>更多请访问：<a href="https://drafts.csswg.org/css-color/" target="_blank" rel="external">CSS颜色模块标准</a></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这篇文章翻译自<a href="https://webkit.org/blog/7477/new-web-features-in-safari-10-1/" target="_blank" rel="external">New Web Features in Safari 10.1</a>，内容略有删减，有些特性我也没搞懂，比如<code>color-gamut</code>，所以可能会有词不达意的地方，望见谅。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;qiaobusi.jpg&quot; alt=&quot;乔布斯与HTML5&quot;&gt;&lt;/p&gt;
&lt;p&gt;伴随着 iOS 10.3 和 macOS Sierra 10.12.4 的更新，一个新版本的Safari也随之而来，其中有许多值得一提的web新特性让前端工程师激动不已，恩，值得
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="翻译" scheme="http://zerosoul.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="前端" scheme="http://zerosoul.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="iOS" scheme="http://zerosoul.github.io/tags/iOS/"/>
    
      <category term="safari" scheme="http://zerosoul.github.io/tags/safari/"/>
    
  </entry>
  
  <entry>
    <title>无规矩不成方圆--前端编码规范</title>
    <link href="http://zerosoul.github.io/2017/03/03/fe-code-style-guide/"/>
    <id>http://zerosoul.github.io/2017/03/03/fe-code-style-guide/</id>
    <published>2017-03-03T01:25:05.000Z</published>
    <updated>2017-03-06T02:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="code.jpg" alt="code style jpg"></p>
<blockquote>
<p>代码是写给人读的，只是机器偶尔执行一下。</p>
</blockquote>
<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><ul>
<li>规范的初衷是为了代码的可维护性，让多人写出的代码像出自同一人之手</li>
<li>该规范具有演化性，会随着实际情况做出相应的调整。开源地址：<a href="https://github.com/zerosoul/fe.code.guide" target="_blank" rel="external">fe.code.guide</a></li>
<li>该规范适用于开发阶段，最后上线的代码不一定符合该规范，因为上线代码可能会经过打包、混淆和压缩</li>
</ul>
<h2 id="通则"><a href="#通则" class="headerlink" title="通则"></a>通则</h2><ul>
<li><strong><a href="http://baike.baidu.com/subview/5018/6328024.htm#viewPageContent" target="_blank" rel="external">KISS原则</a></strong>:坚持简约，避免不必要的复杂化</li>
<li><strong>所有代码小写</strong>（常量命名、特殊名词、纯字符串除外）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//不推荐</div><div class="line"><span class="tag">&lt;<span class="name">A</span> <span class="attr">HREF</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">A</span>&gt;</span></div><div class="line">//推荐</div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img.png"</span> <span class="attr">alt</span>=<span class="string">"Image"</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//不推荐</div><div class="line">color: #E5E5E5;</div><div class="line">//推荐</div><div class="line">color: #e5e5e5;</div></pre></td></tr></table></figure>
<ul>
<li>命名规则（项目，目录，HTML、CSS、JS、图片等静态文件）</li>
</ul>
<p>小写，以下划线分割，例：my_project_name</p>
<ul>
<li>注释（建议以下情况使用注释）<ul>
<li>难于理解的代码段</li>
<li>可能存在错误的代码段</li>
<li>浏览器特殊的HACK代码</li>
<li>业务逻辑强相关的代码</li>
</ul>
</li>
</ul>
<p>代码是人写的，也是由人维护，所以尽可能确保代码具备描述性，做到不注自释。<br>好注释能表达出代码的上下文和目的，不要只是复述从代码就能读出的信息。</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="文档骨架"><a href="#文档骨架" class="headerlink" title="文档骨架"></a>文档骨架</h3><p>PC：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=Edge"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><em>强制浏览器使用标准模式渲染，保证页面效果统一。IE浏览器使用最新版本，即<a href="http://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do" target="_blank" rel="external">Edge Mode</a></em>。</p>
<p>Mobile：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Page title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><em>强制浏览器使用标准模式渲染，保证页面效果统一</em></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li><strong>使用双空格短缩进</strong></li>
<li>在属性中始终书写双引号</li>
<li>自关闭元素不要使用斜杠结尾（<a href="http://blog.jobbole.com/61514/" target="_blank" rel="external">参考此处</a>）</li>
</ul>
<p>常见的自关闭元素：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">hr</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span>&gt;</span> <span class="tag">&lt;<span class="name">link</span>&gt;</span> <span class="tag">&lt;<span class="name">meta</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>不常见的自关闭元素：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">area</span>&gt;</span> <span class="tag">&lt;<span class="name">base</span>&gt;</span> <span class="tag">&lt;<span class="name">col</span>&gt;</span> <span class="tag">&lt;<span class="name">command</span>&gt;</span> <span class="tag">&lt;<span class="name">embed</span>&gt;</span> <span class="tag">&lt;<span class="name">keygen</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">param</span>&gt;</span> <span class="tag">&lt;<span class="name">source</span>&gt;</span> <span class="tag">&lt;<span class="name">track</span>&gt;</span> <span class="tag">&lt;<span class="name">wbr</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="引用CSS和JavaScript文件"><a href="#引用CSS和JavaScript文件" class="headerlink" title="引用CSS和JavaScript文件"></a>引用CSS和JavaScript文件</h3><p>按照HTML5规范，一般来说，当CSS和JS文件被引用时，都会默认以 <code>text/css</code> 和 <code>text/javascript</code> 的方式，没必要特意为其指定 <code>type</code> 类型。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 外部 CSS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"demo.css"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 文档内CSS --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="comment">/* ... */</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- Javascript --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"demo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="精简标签"><a href="#精简标签" class="headerlink" title="精简标签"></a>精简标签</h3><p>书写HTML时尽可能减少冗余的标签。比如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 不推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"avatar"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--推荐 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"avatar"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>另外，尽量不要在HTML写行内style、JS代码，遵守<strong>结构和样式、行为分离</strong>的原则。</p>
<h3 id="实用为王"><a href="#实用为王" class="headerlink" title="实用为王"></a>实用为王</h3><p>尽量遵循 HTML 标准和语义，但是不要以牺牲实用性为代价。任何时候都要尽量使用最少的标签并保持最小的复杂度。</p>
<h3 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span></div><div class="line">  Demo link</div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">alt</span>=<span class="string">"..."</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>class</li>
<li>id,name</li>
<li>data-*</li>
<li>src,for,type,href,value</li>
<li>title,alt</li>
<li>role,aria-*</li>
</ul>
<p><code>class</code>能更好地重用组件，所以打头阵；<code>id</code>更加特定和专属，尽量控制使用。</p>
<h3 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h3><blockquote>
<p>某一元素如果调用了布尔属性，则代表该值为真，否则为假。</p>
</blockquote>
<p>简言之：不要赋值。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">disabled</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">checked</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">selected</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span></div><div class="line"><span class="selector-class">.selector</span>, <span class="selector-class">.selector-secondary</span>, <span class="selector-class">.selector</span><span class="selector-attr">[type=text]</span> &#123;</div><div class="line">  <span class="attribute">padding</span>:<span class="number">15px</span>;</div><div class="line">  <span class="attribute">margin</span>:<span class="number">0px</span> <span class="number">0px</span> <span class="number">15px</span>;</div><div class="line">  <span class="attribute">background-color</span>:<span class="built_in">rgba</span>(0, 0, 0, 0.5);</div><div class="line">  <span class="attribute">box-shadow</span>:<span class="number">0px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#CCC</span>,inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#FFFFFF</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-class">.selector</span>,</div><div class="line"><span class="selector-class">.selector-secondary</span>,</div><div class="line"><span class="selector-class">.selector</span><span class="selector-attr">[type="text"]</span> &#123;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">15px</span>;</div><div class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,0,.5);</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#ccc</span>, inset <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>多个选择器，请换行</li>
<li>区块结束符<code>}</code>独占一行</li>
<li>不要忘记最后一个声明语句的<code>;</code></li>
<li>省略小数点前的<code>0</code>：<code>0.5</code>=&gt;<code>.5</code></li>
<li>零值省略单位：<code>margin: 0px;</code>=&gt;<code>margin: 0</code></li>
<li>只有一条声明可以写在一行</li>
</ul>
<h3 id="声明顺序"><a href="#声明顺序" class="headerlink" title="声明顺序"></a>声明顺序</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.declaration-order</span> &#123;</div><div class="line">  <span class="comment">/* 定位 */</span></div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* 盒模型 */</span></div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* 排版 */</span></div><div class="line">  <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">"Helvetica Neue"</span>, sans-serif;</div><div class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line"></div><div class="line">  <span class="comment">/* 视觉 */</span></div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* 其它 */</span></div><div class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关属性的声明按组以以下顺序排列：</p>
<ol>
<li>定位（Positioning）</li>
<li>盒模型（Box model）</li>
<li>排版（Typographic）</li>
<li>视觉（Visual）</li>
</ol>
<p><strong>定位排首位是因为它可能会让元素脱离文档流并重写盒模型的相关样式</strong></p>
<h3 id="禁止使用-import"><a href="#禁止使用-import" class="headerlink" title="禁止使用@import"></a><strong>禁止使用<code>@import</code></strong></h3><p>原因：<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="external">参考此文</a></p>
<h3 id="正确放置媒体查询语句"><a href="#正确放置媒体查询语句" class="headerlink" title="正确放置媒体查询语句"></a><strong>正确放置媒体查询语句</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.element &#123; ... &#125;</div><div class="line">.element-avatar &#123; ... &#125;</div><div class="line">.element-selected &#123; ... &#125;</div><div class="line"></div><div class="line">@media (min-width: 480px) &#123;</div><div class="line">  .element &#123; ...&#125;</div><div class="line">  .element-avatar &#123; ... &#125;</div><div class="line">  .element-selected &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽可能把媒体查询语句放在相关的规则集后面，不要单独存放到某个文件，也不要放到样式表最后。这样做是为了以后同步修改更方便，相信我，这样做能让后来维护代码的人少骂你几句。</p>
<h3 id="简写虽好，但不要滥用"><a href="#简写虽好，但不要滥用" class="headerlink" title="简写虽好，但不要滥用"></a>简写虽好，但不要滥用</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span></div><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span>;</div><div class="line">  <span class="attribute">background</span>: red;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"image.jpg"</span>);</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">0</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"><span class="selector-class">.element</span> &#123;</div><div class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"image.jpg"</span>);</div><div class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">3px</span>;</div><div class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">3px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一些属性可以合并简写，比如：</p>
<ul>
<li>padding</li>
<li>margin</li>
<li>font</li>
<li>background</li>
<li>border</li>
<li>border-radius</li>
</ul>
<p>属性简写需要非常清楚属性值的正确顺序，而且在大多数情况下并不需要设置属性简写中包含的所有值，所以建议尽量分开声明会更加清晰。使用简写前，想一想有没有必要，<strong>少于三个</strong>合并属性建议不要简写。</p>
<p><em><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Shorthand_properties" target="_blank" rel="external">这里</a>有一篇关于简写的好文章</em></p>
<h3 id="选择器命名采用-分隔"><a href="#选择器命名采用-分隔" class="headerlink" title="选择器命名采用-分隔"></a>选择器命名采用<code>-</code>分隔</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 不推荐 */</span></div><div class="line"> <span class="selector-class">.hotelTitle</span> &#123;</div><div class="line">     <span class="attribute">font-weight</span>: bold;</div><div class="line"> &#125;</div><div class="line"><span class="comment">/* 推荐 */</span></div><div class="line"> <span class="selector-class">.hotel-title</span> &#123;</div><div class="line">     <span class="attribute">font-weight</span>: bold;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>比使用驼峰更加清晰。</li>
<li><strong>产品线-产品-模块-子模块</strong></li>
</ul>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><ul>
<li>JS 换行缩进：采用 4 空格</li>
<li>结束行添加分号<code>;</code></li>
<li>避免使用 eval()</li>
<li>JS调试使用<code>console.log()</code>及<code>console.dir()</code>，避免使用<code>alert()</code>，线上版需要注释或删掉所有调试代码</li>
</ul>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>最外层统一使用单引号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不推荐</span></div><div class="line"><span class="keyword">var</span> x = <span class="string">"test"</span>;</div><div class="line"><span class="comment">// 推荐</span></div><div class="line"><span class="keyword">var</span> y = <span class="string">'foo'</span>,</div><div class="line">    z = <span class="string">'&lt;div id="test"&gt;&lt;/div&gt;'</span>;</div></pre></td></tr></table></figure>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> thisIsMyName;</div><div class="line"><span class="keyword">var</span> goodID;</div><div class="line"><span class="keyword">var</span> reportURL;</div><div class="line"><span class="keyword">var</span> AndroidVersion;</div><div class="line"><span class="keyword">var</span> iOSVersion;</div><div class="line"><span class="keyword">var</span> MAX_COUNT = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 不推荐</span></div><div class="line"><span class="keyword">var</span> body = $(<span class="string">'body'</span>);</div><div class="line"><span class="comment">// 推荐</span></div><div class="line"><span class="keyword">var</span> $body = $(<span class="string">'body'</span>);</div></pre></td></tr></table></figure>
<ul>
<li>标准变量采用驼峰式命名</li>
<li>常量全大写，用下划线连接</li>
<li>特殊处理：<code>ID</code>,<code>URL</code>,<code>Android</code>,<code>iOS</code></li>
<li>构造函数，大写第一个字母</li>
<li>jQuery变量首字符为 <code>$</code>, 私有变量:首字符为<code>_</code></li>
</ul>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingWithItems</span>(<span class="params">items</span>) </span>&#123;</div><div class="line">    <span class="comment">// 使用一个var声明</span></div><div class="line">    <span class="keyword">var</span> value = <span class="number">10</span>,</div><div class="line">        result = value + <span class="number">10</span>,</div><div class="line">        i,</div><div class="line">        len;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = items.length; i &lt; len; i++) &#123;</div><div class="line">        result += <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个函数作用域中所有的变量声明尽量提到函数首部，用一个var声明，不允许出现两个连续的var声明。</p>
<h2 id="Smarty模板"><a href="#Smarty模板" class="headerlink" title="Smarty模板"></a>Smarty模板</h2><h3 id="划清PHP与Smarty的界限"><a href="#划清PHP与Smarty的界限" class="headerlink" title="划清PHP与Smarty的界限"></a>划清PHP与Smarty的界限</h3><p>PHP只是负责输出数据，并保持干净。切勿将业务逻辑代码放入Smarty中。</p>
<h3 id="组合大于继承"><a href="#组合大于继承" class="headerlink" title="组合大于继承"></a>组合大于继承</h3><p>尽量不使用继承，即使使用，继承关系不要超过两层。</p>
<h3 id="逻辑尽可能简洁，判断不要超过三层"><a href="#逻辑尽可能简洁，判断不要超过三层" class="headerlink" title="逻辑尽可能简洁，判断不要超过三层"></a>逻辑尽可能简洁，判断不要超过三层</h3><p>Smarty模板只是负责展示数据，尽量不要掺入逻辑判断，但判断过多时，就应该思考是否应该把这部分判断逻辑放入PHP端？或者，产品的业务逻辑如此复杂，是否已经是走入了错误的方向？如果你有更好的解决方式，奔向PM理论一番吧，少年，如果能想到这一步，你已经在成长。</p>
<p><a href="http://www.smarty.net/best_practices" target="_blank" rel="external">Smarty官方最佳实践</a></p>
<h2 id="性能清单"><a href="#性能清单" class="headerlink" title="性能清单"></a>性能清单</h2><h3 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h3><ul>
<li>是否启用HTTP2？</li>
<li><strong>静态文件是否使用CDN？独立域名？</strong></li>
<li><strong>静态文件域名是否做到无Cookie？</strong></li>
<li>DNS预取功能是否开启？</li>
</ul>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul>
<li>JavaScript/CSS/HTML文件是否合并、压缩？</li>
<li>是否存在行内样式和JS？</li>
<li><strong>CSS有没有使用<code>@import</code>？</strong></li>
<li>静态文本文件有没有开启Gzip？</li>
<li><strong>是否做到科学使用图片格式？（PNG,JPG,GIF…适用场景及尺寸合适）</strong></li>
<li>图片有没有压缩处理？</li>
<li>图片资源有没有开启浏览器缓存？</li>
<li>SVG文件有没有压缩处理？</li>
<li>浏览器缓存是否做到高效利用？</li>
<li><strong>对于非关键资源有没有做到异步或者延迟处理？</strong></li>
</ul>
<h3 id="度量标准"><a href="#度量标准" class="headerlink" title="度量标准"></a>度量标准</h3><p>通常，页面的性能通过以下数据大体感知出：</p>
<ul>
<li>所有文件的数量</li>
<li>所有文件的大小</li>
<li>DomReady时间</li>
<li>页面下载时间</li>
</ul>
<h3 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h3><ul>
<li><strong>CSS在头部加载</strong></li>
<li><strong>JS文件在文档底部加载</strong></li>
<li><strong><code>script</code>标签开启<code>defer</code>特性</strong></li>
<li><strong>假如JS文件在头部加载，放在CSS之后</strong></li>
<li>60fps情况下页面依然可以滚动浏览</li>
<li>禁用<code>document.write</code></li>
<li>防止CSS 动画的滥用</li>
</ul>
<h2 id="硬件性能"><a href="#硬件性能" class="headerlink" title="硬件性能"></a>硬件性能</h2><ul>
<li>CPU使用率</li>
<li>内存使用率</li>
<li>GPU使用率</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>全站HTTPS</li>
<li>站外资源的引用开启HTTPS</li>
<li>启用Robots.txt</li>
<li><strong>XSS成为不可能</strong></li>
<li>开启<code>Content-Security-Policy</code>，并且只允许特指的几个域名</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li>在<code>html</code>标签内正确设置语言</li>
<li>指定<code>charset</code></li>
<li>HTML通过验证</li>
<li>指定404页面</li>
<li>指定页面打印样式</li>
</ul>
<h2 id="上线检查清单"><a href="#上线检查清单" class="headerlink" title="上线检查清单"></a>上线检查清单</h2><ul>
<li>设计稿高度还原（移动端：750）</li>
<li>对业务的理解（有些问题不一定需要靠技术手段解决，锻炼伪需求的辨别能力）</li>
<li>html标签的简洁性，语义性</li>
<li>功能实现优先级：html&gt;CSS&gt;img&amp;JS</li>
<li>渐进增强，优雅降级（PC：&gt;=IE9，Mobile：&gt;=Android 4.0）</li>
<li>交互是否完备</li>
<li>模板和静态页的易用性（把交付，当做产品来做，换位思考，考虑后端开发的感受）e.g.链接的设置</li>
<li>模块化（把代码，当做积木来做，为将来的维护少挖坑）</li>
<li>广告区块有个占位就行，统一占位和样式</li>
<li>readme.txt（命名命的好，代码结构清晰，不readme也行）</li>
<li>知己知彼（smarty模板语言，php better）</li>
<li>新技术的应用（语言、工具）</li>
<li>雅虎军规</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;code.jpg&quot; alt=&quot;code style jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码是写给人读的，只是机器偶尔执行一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; cl
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://zerosoul.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="编码" scheme="http://zerosoul.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
      <category term="规范" scheme="http://zerosoul.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="性能优化" scheme="http://zerosoul.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Array中的filter、map和reduce</title>
    <link href="http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js/"/>
    <id>http://zerosoul.github.io/2016/12/06/array-filter-map-reduce-in-js/</id>
    <published>2016-12-06T03:00:15.000Z</published>
    <updated>2016-12-06T09:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>前几天<a href="http://zerosoul.github.io/2016/11/29/array-filter-trick/">写了篇文章</a>科普了下Javascript中<code>Array.filter()</code>的妙用，后来无意间发现了<a href="http://atendesigngroup.com/blog/array-map-filter-and-reduce-js" target="_blank" rel="external">一篇好文章</a>，一次性科普了三个API：<code>filter</code>、<code>map</code>和<code>reduce</code>，生动形象，尤其是配图，显然是用了心思。下面是译文：</p>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><img src="array-1.png" alt="array top image"></p>
<p>最近，一直在为一个客户做一个视觉化数据的项目，从服务端API拉取数据回来然后转换出视觉效果，自然少不了大量的数据操作，为此我一再使用Javascript中的Array 三个API：<code>filter</code>、<code>map</code>和<code>reduce</code>。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">Map</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">Filter</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="external">Reduce</a>常常被用于对一个数组做一些操作，进而转换成某个新的东西（数据类型不一定还是数组哦~）。下面是我对这三个API的直观认识：</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="array-map.png" alt="array-map"><br>你想将一个数组中的每一项做个转换，结果生成了一个新数组，并且新数组的长度和原数组一致。</p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p><img src="array-filter.png" alt="array-filter"><br>你想将一个数组做一个过滤，按照某规则提取出一些特定的项来。结果也生成了一个新数组，但新数组的长度小于或等于原数组。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p><img src="array-reduce.png" alt="array-reduce"><br>你想通过遍历一个数组的每一项来计算出一个新东西，最后生成的结果可以是任何类型的变量：一个新数组，一个新对象，一个新布尔值…</p>
<p><code>filter</code>、<code>map</code>和<code>reduce</code>共同点就是并不会对原数组做任何改动，结果都是生成一个新变量。让我们来看一些例子：</p>
<h2 id="Array-map"><a href="#Array-map" class="headerlink" title="Array.map()"></a>Array.map()</h2><p>现在我们有一个对象列表，其中每个对象代表的是一种变形金刚（译注：看来这位歪果仁是个变形金刚粉丝）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> transformers = [</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Optimus Prime'</span>,</div><div class="line">    form: <span class="string">'Freightliner Truck'</span>,</div><div class="line">    team: <span class="string">'Autobot'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Megatron'</span>,</div><div class="line">    form: <span class="string">'Gun'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Bumblebee'</span>,</div><div class="line">    form: <span class="string">'VW Beetle'</span>,</div><div class="line">    team: <span class="string">'Autobot'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Soundwave'</span>,</div><div class="line">    form: <span class="string">'Walkman'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span></div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>那么，问题来了，如果想得到一个包含所有变形（form）的列表该怎么做呢？<code>Array.map()</code>让一切变得简单。它的基本使用语法是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.map(callback(item));</div></pre></td></tr></table></figure></p>
<p>当然，还有种更复杂点的语法场景，只不过不常用到：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.map(callback(item[, index], array])[, thisArg]);</div></pre></td></tr></table></figure></p>
<p><code>callback</code>会遍历数组的每个元素，在其中返回的每一个数值将会组成新数组。<code>callback</code>有多种书写方式：<br>命名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getForm</span>(<span class="params">transformer</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> transformer.form;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> robotsInDisguise = transformers.map(getForm);</div><div class="line"><span class="comment">/** robosInDisguise === ['Freightliner Truck', 'Gun', 'VW Beetle', 'Walkman'] */</span></div></pre></td></tr></table></figure></p>
<p>匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">robotsInDisguise = transformers.map(<span class="function"><span class="keyword">function</span>(<span class="params">transformer</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> transformer.form;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>箭头函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">robotsInDisguise = transformers.map(transformer =&gt; transformer.form);</div></pre></td></tr></table></figure></p>
<p>ES2015的箭头函数和<code>Array.map()</code>搭配使用简直不能更爽了！</p>
<h2 id="Array-filter"><a href="#Array-filter" class="headerlink" title="Array.filter()"></a>Array.filter()</h2><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.filter(callback(item));</div></pre></td></tr></table></figure></p>
<p><code>callback</code>将数组元素当参数传入，并返回一个布尔值。当返回值为真时，该元素被加入新数组中，反之则被过滤掉。<br>现在我们把这些变形金刚过滤出<strong>汽车人</strong>(Autobots)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isAutobot</span>(<span class="params">transformer</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> transformer.team === ‘Autobot’;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> autobots = transformers.filter(isAutobot);</div><div class="line"><span class="comment">/**</span></div><div class="line">autobots ==  [</div><div class="line">  &#123;</div><div class="line">    name: 'Optimus Prime',</div><div class="line">    form: 'Freightliner Truck',</div><div class="line">    team: 'Autobot'</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: 'Bumblebee',</div><div class="line">    form: 'VW Beetle',</div><div class="line">    team: 'Autobot'</div><div class="line">  &#125;</div><div class="line">]</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="Array-reduce"><a href="#Array-reduce" class="headerlink" title="Array.reduce()"></a>Array.reduce()</h2><p><code>Array.reduce()</code>是通过遍历每个数组元素对其做运算，因此，也是三个API之间最富有技巧的，其使用语法也略显复杂：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.prototype.reduce(callback(previousValue, currentValue[, index], array]), initialValue)</div></pre></td></tr></table></figure></p>
<p>谨记一条：我们是将数组元素通过遍历减少到一个值。比如现在有一组<strong>可组合变形金刚</strong>（译者注：我也不知道什么鬼，该怎么翻译，原词：Construction Transformers），它们能够组合成更大的变形金刚，我们可以通过代码来做出这样的组合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constructicons = [</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Scrapper'</span>,</div><div class="line">    form: <span class="string">'Freightliner Truck'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'rightLeg'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Hook'</span>,</div><div class="line">    form: <span class="string">'Mobile Crane'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'upperTorso'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Bonecrusher'</span>,</div><div class="line">    form: <span class="string">'Bulldozer'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'leftArm'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Scavenger'</span>,</div><div class="line">    form: <span class="string">'Excavator'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'rightArm'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Mixmaster'</span>,</div><div class="line">    form: <span class="string">'Concrete Mixer'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'leftLeg'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'Long Haul'</span>,</div><div class="line">    form: <span class="string">'Dump Truck'</span>,</div><div class="line">    team: <span class="string">'Decepticon'</span>,</div><div class="line">    bodyPart: <span class="string">'lowerTorso'</span></div><div class="line">  &#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>Reduce的<code>callback</code>需要至少两个参数。第一个是从上次遍历中返回的一个值，第二个是当前数组遍历到的一个值，返回值又将当做第一个参数被传入到下一次遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assemble</span>(<span class="params">combiner, transformer</span>) </span>&#123;</div><div class="line">  <span class="comment">//每次遍历都会将当前的变形金刚（transformer）的名字加入到组合器（combiner）的form中去。</span></div><div class="line">  combiner.form[transformer.bodyPart] = transformer.name;</div><div class="line">  <span class="keyword">return</span> combiner;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们可以在调用reduce的时候，将<code>assemble</code>当做第一个参数传入，第二个参数是用来初次调用时的初始数据。接下来的例子便是我们提供一个仅仅有名字（name）和派别（team）的变形金刚，通过reduce中的<code>assemble</code>我们来组合成一个强大的变形金刚吧！</p>
<p><img src="transform.gif" alt="transforming"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> devastator = constructicons.reduce(assemble, &#123;</div><div class="line">  name: ‘Devastator’,</div><div class="line">  team: ‘Decepticon’,</div><div class="line">  form: &#123;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">/*</span></div><div class="line">devastator == &#123;</div><div class="line">  name: ‘Devastator’,</div><div class="line">  team: ‘Decepticon’,</div><div class="line">  form: &#123;</div><div class="line">    leftArm: "Bonecrusher"</div><div class="line">    leftLeg: "Mixmaster"</div><div class="line">    lowerTorso: "Long Haul"</div><div class="line">    rightArm: "Scavenger"</div><div class="line">    rightLeg: "Scrapper"</div><div class="line">    upperTorso: "Hook"</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>这些三个基本API一旦组合起来使用，也是很强大的。在此只是根据自己的使用经验抛砖引玉，想进一步了解的同学可以移步万能的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN有关Array API的文档</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;前几天&lt;a href=&quot;http://zerosoul.github.io/2016/11/29/array
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="译文" scheme="http://zerosoul.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="javascript" scheme="http://zerosoul.github.io/tags/javascript/"/>
    
      <category term="array" scheme="http://zerosoul.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中Array.filter()的妙用</title>
    <link href="http://zerosoul.github.io/2016/11/29/array-filter-trick/"/>
    <id>http://zerosoul.github.io/2016/11/29/array-filter-trick/</id>
    <published>2016-11-29T07:54:09.000Z</published>
    <updated>2016-12-06T02:02:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="filter简述"><a href="#filter简述" class="headerlink" title="filter简述"></a>filter简述</h1><p><code>filter</code>是Javascript中Array常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。</p>
<p>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external"><code>map</code></a>类似，Array的<code>filter</code>也接收一个函数。但是和map不同的是，<code>filter</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</div><div class="line">&#125;);</div><div class="line">r; <span class="comment">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>
<p>把一个Array中的空字符串删掉，可以这么写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</div><div class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注：IE9(不包含IE9)以下的版本没有trim()方法</span></div><div class="line">&#125;);</div><div class="line">arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>
<p>可见用<code>filter</code>这个高阶函数，关键在于正确实现一个“筛选”函数。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p><code>filter</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(element); <span class="comment">// 依次打印'A', 'B', 'C'</span></div><div class="line">    <span class="built_in">console</span>.log(index); <span class="comment">// 依次打印0, 1, 2</span></div><div class="line">    <span class="built_in">console</span>.log(self); <span class="comment">// self就是变量arr</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>利用<code>filter</code>，可以巧妙地去除Array的重复元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r,</div><div class="line">    arr = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'banana'</span>, <span class="string">'pear'</span>, <span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'orange'</span>, <span class="string">'strawberry'</span>];</div><div class="line"></div><div class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> self.indexOf(element) === index;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(r.toString());</div></pre></td></tr></table></figure></p>
<p>去除重复元素依靠的是<code>indexOf</code>总是返回第一个元素的位置，后续的重复元素位置与<code>indexOf</code>返回的位置不相等，因此被<code>filter</code>滤掉了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;filter简述&quot;&gt;&lt;a href=&quot;#filter简述&quot; class=&quot;headerlink&quot; title=&quot;filter简述&quot;&gt;&lt;/a&gt;filter简述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;是Javascript中Array常用的操作，它用于把
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://zerosoul.github.io/tags/javascript/"/>
    
      <category term="array" scheme="http://zerosoul.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>移动端HTML5页面开发备忘录</title>
    <link href="http://zerosoul.github.io/2016/11/15/h5-memo/"/>
    <id>http://zerosoul.github.io/2016/11/15/h5-memo/</id>
    <published>2016-11-15T08:17:38.000Z</published>
    <updated>2016-11-30T10:06:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="html5.jpg" alt="html5"><br>把平时开发工作中遇到的一些问题写下来，权当备忘录。</p>
<h1 id="有关Meta"><a href="#有关Meta" class="headerlink" title="有关Meta"></a>有关Meta</h1><h2 id="基本Meta"><a href="#基本Meta" class="headerlink" title="基本Meta"></a>基本Meta</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 设置缩放 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, user-scalable=no, minimal-ui"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 可隐藏地址栏，仅针对IOS的Safari（注：IOS7.0版本以后，safari上已看不到效果） --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 仅针对IOS的Safari顶端状态条的样式（可选default/black/black-translucent ） --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- IOS中禁用将数字识别为电话号码/忽略Android平台中对邮箱地址的识别 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no, email=no"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h2 id="搜索引擎Meta"><a href="#搜索引擎Meta" class="headerlink" title="搜索引擎Meta"></a>搜索引擎Meta</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 搜索引擎索引方式：通常有如下几种取值：none，noindex，nofollow，all，index和follow。--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!--</span></div><div class="line">    all：文件将被检索，且页面上的链接可以被查询；</div><div class="line">    none：文件将不被检索，且页面上的链接不可以被查询；</div><div class="line">    index：文件将被检索；</div><div class="line">    follow：页面上的链接可以被查询；</div><div class="line">    noindex：文件将不被检索；</div><div class="line">    nofollow：页面上的链接不可以被查询。</div><div class="line"> --&gt;</div></pre></td></tr></table></figure>
<h2 id="页面缓存设置Meta"><a href="#页面缓存设置Meta" class="headerlink" title="页面缓存设置Meta"></a>页面缓存设置Meta</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 清除缓存 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"0"</span>&gt;</span></div></pre></td></tr></table></figure>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="移动端字体设置"><a href="#移动端字体设置" class="headerlink" title="移动端字体设置"></a>移动端字体设置</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*中英字体名对照表</span></div><div class="line">宋体      SimSun</div><div class="line">黑体      SimHei</div><div class="line">微信雅黑   Microsoft Yahei</div><div class="line">微软正黑体 Microsoft JhengHei</div><div class="line">新宋体    NSimSun</div><div class="line">新细明体  MingLiU</div><div class="line">细明体    MingLiU</div><div class="line">标楷体    DFKai-SB</div><div class="line">仿宋     FangSong</div><div class="line">楷体     KaiTi</div><div class="line">仿宋_GB2312  FangSong_GB2312</div><div class="line">楷体_GB2312  KaiTi_GB2312  </div><div class="line">说明：中文字体多数使用宋雅黑，英文用Helvetica</div><div class="line">*/</div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-family</span>: Microsoft Yahei,SimSun,Helvetica; &#125;</div></pre></td></tr></table></figure>
<h2 id="打电话发短信写邮件"><a href="#打电话发短信写邮件" class="headerlink" title="打电话发短信写邮件"></a>打电话发短信写邮件</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 打电话</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:010-88888"</span>&gt;</span>打电话给:010-88888<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">//  发短信</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"sms:88888"</span>&gt;</span>发短信给: 88888<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">// 写邮件</div><div class="line">//注：在添加这些功能时，第一个功能以"?"开头，后面的以"&amp;"开头</div><div class="line">//1.普通邮件</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//2.收件地址后添加?cc=开头，可添加抄送地址（Android存在兼容问题）</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?cc=666@wtf.com"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//3.跟着抄送地址后，写上&amp;bcc=,可添加密件抄送地址（Android存在兼容问题）</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?cc=666@wtf.com&amp;bcc=384900096@wtf.com"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//4.包含多个收件人、抄送、密件抄送人，用分号(;)隔开多个邮件人的地址</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com;384900096@wtf.com"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//5.包含主题，用?subject=</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?subject=邮件主题"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//6.包含内容，用?body=;如内容包含文本，使用%0A给文本换行 </div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?body=邮件主题内容%0A我是第二行内容%0A你没有猜错，这是我是第三行。"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//7.内容包含链接，含http(s)://等的文本自动转化为链接</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?body=http://www.wtf.com"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//8.内容包含图片（PC不支持）</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com?body=&lt;img src='images/torrent.jpg' /&gt;"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">//9.完整示例</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:haha@wtf.com;384900096@wtf.com?cc=666@wtf.com&amp;bcc=993233461@wtf.com&amp;subject=[邮件主题]&amp;body=我是第一行内容%0A%0Ahttp://www.baidu.com%0A%0A&lt;img src='images/1.jpg' /&gt;"</span>&gt;</span>快来点我啊，给你发种子。<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="touch事件"><a href="#touch事件" class="headerlink" title="touch事件"></a>touch事件</h2><p>事件响应顺序：<code>ontouchstart</code>  &gt; <code>ontouchmove</code>  &gt; <code>ontouchend</code> &gt; <code>onclick</code></p>
<ul>
<li><code>touchstart</code>——当手指触碰屏幕时候发生</li>
<li><code>touchmove</code>——当手指在屏幕上滑动时连续触发。</li>
<li>通常在滑屏页面，会调用<code>event</code>的<code>preventDefault()</code>可以阻止默认情况的发生：阻止页面滚动</li>
<li><code>touchend</code>——当手指离开屏幕时触发</li>
<li><code>touchcancel</code>——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面<code>alert()</code>，此时会触发该事件，这个事件比较少用。</li>
</ul>
<p>TouchEvent说明：</p>
<ul>
<li>touches：屏幕上所有手指的信息</li>
<li>targetTouches：手指在目标区域的手指信息</li>
<li>changedTouches：最近一次触发该事件的手指信息</li>
<li>touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，用于计算手指信息</li>
</ul>
<p>参数信息(changedTouches[0])</p>
<ul>
<li>clientX、clientY在显示区的坐标</li>
<li>target：当前元素</li>
</ul>
<h2 id="科普：移动端click事件200-300ms的延时响应"><a href="#科普：移动端click事件200-300ms的延时响应" class="headerlink" title="科普：移动端click事件200-300ms的延时响应"></a>科普：移动端click事件200-300ms的延时响应</h2><p>以下是历史原因：</p>
<blockquote>
<p>2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。<br>双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。<br>原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接<code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code>，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。</p>
</blockquote>
<p>造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。</p>
<p>解决方案：</p>
<ul>
<li><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="external">fastclick</a></li>
<li>zepto的<a href="https://github.com/madrobby/zepto/blob/master/src/touch.js#files" target="_blank" rel="external">touch模块</a></li>
</ul>
<h2 id="点击元素产生背景或边框问题"><a href="#点击元素产生背景或边框问题" class="headerlink" title="点击元素产生背景或边框问题"></a>点击元素产生背景或边框问题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a,button,input,textarea &#123; </div><div class="line">    -webkit-tap-highlight-color: rgba(0,0,0,0); </div><div class="line">    -webkit-user-modify:read-write-plaintext-only; //-webkit-user-modify有个副作用，就是输入法不再能够输入多个字符</div><div class="line">&#125;   </div><div class="line">/*也可以...，简单粗暴*/</div><div class="line">* &#123; -webkit-tap-highlight-color: rgba(0,0,0,0); &#125;</div></pre></td></tr></table></figure>
<h2 id="字体单位font-size选择px还是rem"><a href="#字体单位font-size选择px还是rem" class="headerlink" title="字体单位font-size选择px还是rem"></a>字体单位font-size选择px还是rem</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*如需适配多种移动设备，建议使用rem。以下为参考值：*/</span></div><div class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">62.5%</span>; &#125;   <span class="comment">/*10÷16 = 62.5%*/</span></div><div class="line"><span class="comment">/*设置12px字体。</span></div><div class="line">注：在rem前要加上对应的px值，解决不支持rem的浏览器的兼容问题，做到优雅降级*/</div><div class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; <span class="attribute">font-size</span>:<span class="number">1.2rem</span>; &#125;</div></pre></td></tr></table></figure>
<h2 id="其它一些实用CSS技巧"><a href="#其它一些实用CSS技巧" class="headerlink" title="其它一些实用CSS技巧"></a>其它一些实用CSS技巧</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*禁止长按链接与图片弹出菜单*/</span></div><div class="line"><span class="selector-tag">a</span>,<span class="selector-tag">img</span> &#123; <span class="attribute">-webkit-touch-callout</span>: none &#125;    </div><div class="line"><span class="comment">/*禁止ios和android用户选中文字*/</span></div><div class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span> &#123;<span class="attribute">-webkit-user-select</span>:none; <span class="attribute">user-select</span>: none; &#125;</div><div class="line"><span class="comment">/*改变输入框placeholder的颜色值*/</span></div><div class="line"><span class="selector-pseudo">::-webkit-input-placeholder</span> &#123; <span class="comment">/* WebKit browsers */</span></div><div class="line"><span class="attribute">color</span>: <span class="number">#999</span>; &#125;</div><div class="line"><span class="selector-pseudo">:-moz-placeholder</span> &#123; <span class="comment">/* Mozilla Firefox 4 to 18 */</span></div><div class="line"><span class="attribute">color</span>: <span class="number">#999</span>; &#125;</div><div class="line"><span class="selector-pseudo">::-moz-placeholder</span> &#123; <span class="comment">/* Mozilla Firefox 19+ */</span></div><div class="line"><span class="attribute">color</span>: <span class="number">#999</span>; &#125;</div><div class="line"><span class="selector-pseudo">:-ms-input-placeholder</span> &#123; <span class="comment">/* Internet Explorer 10+ */</span></div><div class="line"><span class="attribute">color</span>: <span class="number">#999</span>; &#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123; <span class="attribute">color</span>:<span class="number">#999</span>; &#125;</div><div class="line"></div><div class="line"><span class="comment">/*android上去掉语音输入按钮*/</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-speech-button</span> &#123;<span class="attribute">display</span>: none&#125;</div></pre></td></tr></table></figure>
<h2 id="禁用input在ios下，输入英文首字母的默认大写"><a href="#禁用input在ios下，输入英文首字母的默认大写" class="headerlink" title="禁用input在ios下，输入英文首字母的默认大写"></a>禁用input在ios下，输入英文首字母的默认大写</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autocapitalize</span>=<span class="string">"off"</span> <span class="attr">autocorrect</span>=<span class="string">"off"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h2 id="屏幕旋转的事件和样式"><a href="#屏幕旋转的事件和样式" class="headerlink" title="屏幕旋转的事件和样式"></a>屏幕旋转的事件和样式</h2><p>JS处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">orientInit</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> orientChk = <span class="built_in">document</span>.documentElement.clientWidth &gt; <span class="built_in">document</span>.documentElement.clientHeight?<span class="string">'landscape'</span>:<span class="string">'portrait'</span>;</div><div class="line">    <span class="keyword">if</span>(orientChk ==<span class="string">'lapdscape'</span>)&#123;</div><div class="line">        <span class="comment">//横屏下需要执行代码</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//竖屏下需要执行代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">orientInit();</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'onorientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span>?<span class="string">'orientationchange'</span>:<span class="string">'resize'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    setTimeout(orientInit, <span class="number">100</span>);</div><div class="line">&#125;,<span class="literal">false</span>)</div></pre></td></tr></table></figure></p>
<p>CSS处理：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*竖屏时样式*/</span></div><div class="line">@<span class="keyword">media</span> all and (orientation:portrait)&#123;   &#125;</div><div class="line"><span class="comment">/*横屏时样式*/</span></div><div class="line">@<span class="keyword">media</span> all and (orientation:landscape)&#123;   &#125;</div></pre></td></tr></table></figure></p>
<h2 id="播放视频不全屏"><a href="#播放视频不全屏" class="headerlink" title="播放视频不全屏"></a>播放视频不全屏</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line">1.ios7+支持自动播放</div><div class="line">2.支持Airplay的设备（如：音箱、Apple TV)播放</div><div class="line">x-webkit-airplay="true" </div><div class="line">3.播放视频不全屏</div><div class="line">webkit-playsinline="true" </div><div class="line">--&gt;</div><div class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">x-webkit-airplay</span>=<span class="string">"true"</span> <span class="attr">webkit-playsinline</span>=<span class="string">"true"</span> <span class="attr">preload</span>=<span class="string">"auto"</span> <span class="attr">autoplay</span> <span class="attr">src</span>=<span class="string">"http://"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="消除transition闪屏"><a href="#消除transition闪屏" class="headerlink" title="消除transition闪屏"></a>消除transition闪屏</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.css</span> &#123;</div><div class="line">    <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</div><div class="line">    <span class="attribute">-webkit-backface-visibility</span>: hidden;</div><div class="line">    <span class="attribute">-webkit-perspective</span>: <span class="number">1000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;html5.jpg&quot; alt=&quot;html5&quot;&gt;&lt;br&gt;把平时开发工作中遇到的一些问题写下来，权当备忘录。&lt;/p&gt;
&lt;h1 id=&quot;有关Meta&quot;&gt;&lt;a href=&quot;#有关Meta&quot; class=&quot;headerlink&quot; title=&quot;有关Meta&quot;&gt;&lt;/
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="html5" scheme="http://zerosoul.github.io/tags/html5/"/>
    
      <category term="备忘录" scheme="http://zerosoul.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>村上春树：人生马拉松</title>
    <link href="http://zerosoul.github.io/2016/06/22/running-life/"/>
    <id>http://zerosoul.github.io/2016/06/22/running-life/</id>
    <published>2016-06-22T08:17:05.000Z</published>
    <updated>2016-06-22T08:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="cscs.jpg" alt="村上春树"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年开始跑步，现在隔三差五地跑5公里，基本养成了习惯。城市的喧嚣让人无法沉静，跑步让我恢复孤独与平静，虽然看过村上春树的《当我跑步时我谈些什么》，再读到下面文章的时候还是特别有感触，与你共勉。</p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>我33岁那年秋天决定以写小说为生。为了保持健康，我开始跑步，每天凌晨4点起床，写作4小时，跑10公里。 </p>
<p>我是那种容易发胖的体质。我妻子却无论怎么吃也胖不起来。这让我时常陷入沉思：“<strong>人生真是不公平啊！一些人无需认真就能得到的东西，另一些人却需要付出很多才能换来。</strong>”<br>不过转念一想，那些不费吹灰之力就能保持苗条的人，不会像我这样重视饮食和运动，也许老化得更快。什么才是公平，还得从长计议。 </p>
<p>几年之后，我终于步入小说家的行列，还成功减掉了多余的体重并戒掉了烟瘾。说起坚持跑步，总有人向我表示钦佩：“你真是意志超人啊！”说老实话，我觉得跑步这东西和意志没多大关联。能坚持跑步，恐怕还是因为这项运动合乎我的要求：不需要伙伴或对手，也不需要特别的器械和场所。人生本来如此：喜欢的事自然可以坚持，不喜欢的怎么也长久不了。 </p>
<p>在这期间，我坚持每年都参加一次马拉松比赛，不过100公里长的“超级马拉松”只跑过一次。那次经历真是终身难忘。 </p>
<p>那是1996年6月23日，我报名参加了在日本北海道佐吕间湖畔举行的超级马拉松大赛，全程100公里。清晨5点，我踌躇满志地站在了起跑线上。比赛的前半段是从起点到55公里休息站间的路程。没什么好说的，我只是安静地向前跑、跑、跑，感觉和每周例行的锻炼一样。到达55公里休息站后，我换了身干净衣服，吃了些妻子准备的点心。这时我发现双脚有些肿胀，于是赶紧换上一双大半号的跑鞋，又继续上路了。<br>从55公里到75公里的路程变得极其痛苦。此时的我心里念叨着向前冲，但身子却不听使唤。我拼命摆动手臂，觉得自己像块在绞肉机里艰难移动的牛肉，累的几乎要瘫倒在地。一会功夫，就有选手接二连三超过了我。最让人心焦的是，一位70多岁的老奶奶超过我时大喊：“坚持下去！” </p>
<p>“怎么办？还有一半路，如何挺过去？”这时，我想起一本书上介绍的窍门。于是我开始默念：“<strong>我不是人！我是一架机器。我没有感觉。我只会前进！</strong>”这句咒语反复在脑子里转圈。我不再看远方，只把目标放在前面3米远处。天空和风、草地、观众、喝彩声、现实、过去——所有这些都被我排除在外。 </p>
<p>神奇的是，不知从哪一秒开始，我浑身的痛楚突然消失。整个人仿佛进入自动运行状态。我开始不断超越他人。接近最后一段赛程时，已经将200多人甩在身后。 </p>
<p>下午4点42分，我终于到达终点，成绩是11小时42分。这次经历让我意识到：终点线只是一个记号而已，其实并没有什么意义，关键是这一路你是如何跑的。人生也是如此。 </p>
<p>当时的我只有30多岁，但也不能称为“小伙子”了。这是耶稣死去的年龄。在这个年纪，我正式站在文学的起跑线上——虽然已不再年轻。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;cscs.jpg&quot; alt=&quot;村上春树&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;去年开始跑步，现在隔三差五地跑5公里，基本养成了习惯。城市的喧
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="跑步" scheme="http://zerosoul.github.io/tags/%E8%B7%91%E6%AD%A5/"/>
    
      <category term="马拉松" scheme="http://zerosoul.github.io/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
      <category term="村上春树" scheme="http://zerosoul.github.io/tags/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>读《Web全栈工程师的自我修养》</title>
    <link href="http://zerosoul.github.io/2016/06/18/about-full-stack-engineer/"/>
    <id>http://zerosoul.github.io/2016/06/18/about-full-stack-engineer/</id>
    <published>2016-06-18T10:19:44.000Z</published>
    <updated>2016-06-18T10:10:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="fullstack.jpg" alt="full stack engineer"><br>全栈工程师现在是个很热的话题，如何定义全栈工程师？在著名的问答网站Quora上有人提出了这个问题，其中一个获得了高票的回答是：</p>
<blockquote>
<p>全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用栈 </p>
</blockquote>
<p>深以为然，所以，全栈工程师应该分为<strong>Web全栈</strong>和<strong>App全栈</strong>。恰巧最近看了本有关<strong>Web全栈工程师</strong>的书，记录下其中一些观点。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul>
<li>应该从能力和思维方式两方面来判定一个人是否是一个合格的全栈工程师。</li>
<li>对于一些经理来说，宁可雇佣多个可管理的普通工程师，也不愿意聘请一个不可管理的天才工程师。</li>
<li>一个前端工程师可能会不加思考地实现视觉设计稿，因为他的岗位说明里规定了自己的职责，这其中不包括质疑设计稿，所以他忽略了自己的最终目标：让产品更好。</li>
<li>全栈工程师除了在一个专精知识领域有深入研究之外，还以知识广博和解决问题能力强著称。</li>
<li>Done is better than perfect</li>
<li>老板雇佣一个员工，不是因为他能写程序，而是因为他能帮助自己赚钱。赚钱有两种方法：减少成本和增加收入。</li>
<li>如果增加一个用户需要的功能是加分项的话，拒绝一个用户不需要的需求更加值得推崇。</li>
<li>要先看看有哪些问题需要解决，然后再补充您的工具箱。永远从商业目标的角度来决定学习什么，而不是纯粹为了锻炼技术能力去学习。</li>
<li>如果我开创一个公司需要招聘“全栈工程师”，我要求的三个能力就是一专多长、关注商业目标和关注用户体验。</li>
<li>绕开每个人都会去做的事情–投简历–转而做一个自己的作品，这就给企业传达了一个信号。</li>
<li>主动性是全栈工程师必备的一个特质，没有一个全栈工程师是被别人逼出来的。</li>
<li>每个人都要有意识地维护自己的作品集，它在半年一次的考核、晋升面试甚至以后的跳槽中都非常有用。</li>
<li>尽量减少同一域下的HTTP请求数，以及尽量减少每一个资源的体积。</li>
<li>把静态资源放在非主域名下，除了可以增加浏览器并发，还可以减少HTTP请求中携带的不必要的cookie。</li>
<li><code>gzip</code>是一种开源的数据压缩算法，其中<code>g</code>代表免费的意思。</li>
<li>DDoS攻击者喜欢攻击的页面一般是会对数据库进行写操作的页面，这样的页面无法静态化，服务器更容易宕机。</li>
<li>越接近高级工程师，越考察对某个点的本质理解，以及在项目和团队中的引导作用，而不是对某工具的使用经验。</li>
<li>框架应该是比库更广泛的概念。一个库是一系列对象、方法等代码，您的应用程序可以把这个库<em>链接</em>进来，起到了重用代码的作用，剩下了重写这部分代码的工作量，而一个框架是一个系统中可重用的一部分。</li>
<li>行动重于计划，自己给自己挠痒。</li>
<li>因为大家害怕失败，所以想把产品调整得完美无缺才发布。但是世界上成功的软件都不是完美的软件，而是在合适的时间发布的、刚刚够用的产品。如果它能活下来，在后面的版本中，他才有机会越来越好。</li>
<li>让市场认可你的能力，而不是让老板认可，因为老板会变，老板的标准不一致，而市场是一致的。</li>
<li><a href="http://semver.org/" target="_blank" rel="external">semver</a> &amp; <a href="https://docs.npmjs.com/files/package.json#dependencies" target="_blank" rel="external">npm dependencies rules</a></li>
<li>架构是当项目变得复杂之后必须考虑的问题，而项目总是会变得复杂的。</li>
<li>“任何能用Javascript实现的，最终都必将用Javascript实现。”<em>Atwood定律</em></li>
<li>语言只负责描述一个程序，而程序运行的速度，不取决于语言，而是算法和编译器的质量。</li>
<li>如果您平时没有做重要的事情，就会发现自己常常在做紧急的事情。<ul>
<li>如果平时没有注意锻炼身体，就会常常去医院，花费更多时间</li>
<li>如果没有培养后辈，为每个项目设置接班人，就会常常需要到处救火。</li>
<li>如果没有配置好版本管理系统就开始工作，就会浪费更多时间去找回丢失的代码</li>
<li>如果偷懒硬编码一些变量在代码中，后续会花费更多时间过去调试</li>
</ul>
</li>
<li>时间四象限：<br><img src="time.jpg" alt="four blocks"></li>
<li>拿工作时长来拼，这是体力劳动时代打工者的心态在作祟。</li>
<li>程序员大致分两种：科学家和工程师。科学家关注技术是否优越，而工程师关注产品是否完美。</li>
<li>懒惰的终极原因就是你想逃避这件事。</li>
<li>耐心是一种能力</li>
<li>用市场最高价格雇佣高效能人士组成团队 <em>Netflix企业文化</em></li>
<li>所谓自我提升，首先是接纳自我，而不是贬低自我的性格。</li>
<li>不要为了迎合主流社会，而伪装成一个外向、热情、合群的人。</li>
<li>项目的定义是：在一定的约束条件下（时间和资源），具有明确目标的一次性任务。</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>做自己感兴趣的事情，学想学的知识，不要怕走偏了，如果有人说不务正业，那就让他们说去吧。如果你能远离传统的路子，将会不同凡响。  <em>–Steve Jobs</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;fullstack.jpg&quot; alt=&quot;full stack engineer&quot;&gt;&lt;br&gt;全栈工程师现在是个很热的话题，如何定义全栈工程师？在著名的问答网站Quora上有人提出了这个问题，其中一个获得了高票的回答是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="全栈工程师" scheme="http://zerosoul.github.io/tags/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    
      <category term="笔记" scheme="http://zerosoul.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="全栈" scheme="http://zerosoul.github.io/tags/%E5%85%A8%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>世界那么大，TA们想看看</title>
    <link href="http://zerosoul.github.io/2016/06/17/take-parents-to-beijing/"/>
    <id>http://zerosoul.github.io/2016/06/17/take-parents-to-beijing/</id>
    <published>2016-06-17T02:27:49.000Z</published>
    <updated>2016-06-17T06:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="parents.jpg" alt="parents"></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>去年夏天把父母和奶奶接北京玩了几天，担心奶奶体力问题，还备用了轮椅。结果几天下来，老人家依然劲头十足，我却累蔫儿了。</p>
<p>好吧，以上不是重点，重点是游玩期间我做了个视频，放在了<a href="https://vimeo.com/146186682" target="_blank" rel="external">网上</a>（可以直接跳到文章底部观看）。令我惊讶的是，半年多过去了，突然有歪果仁来了封邮件，问视频是怎么做的：<strong>How did you accomplish it?Amazing!</strong>。哎，这个没见过世面的歪果仁，<a href="https://vimeo.com/channels/staffpicks" target="_blank" rel="external">Vimeo</a>上的视频一个比一个精彩，如果排行的话，我只能垫底。不过这位歪果仁兄既然诚心诚意地发问，我也就很负责任地回复了：<strong>iPhone6 + iMovie + selfie stick</strong>。对，很简洁，很任性，很清真，我大概能猜到歪果仁看到后的表情：(╯‵□′)╯︵┻━┻。</p>
<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><iframe src="https://player.vimeo.com/video/146186682?loop=1&color=ffffff&title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe></p>
<p style="text-align:center;width:100%;">世界那么大 TA们想看看</p>

<p><em>注：微信下视频加载不出来，请移步浏览器</em></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>其实不只歪果仁，有些国内的朋友也问过我几次同样的问题，那么有必要罗列下当初用到的工具，仅供参考。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li>iPhone 6 64G：应该是刚买了没多久，就拿来录像了，效果挺好的。庆幸当初选择的是64G，否则后面内存就捉襟见肘了。</li>
<li>iPad Air：主要用来编辑视频，使用自带的iMovie</li>
<li>Macbook Pro：用来上传视频，好吧，有点打酱油的一个硬件</li>
<li>自拍杆（带遥控）：淘宝了一个，链接点<a href="https://detail.tmall.com/item.htm?id=42154967278&amp;spm=a1z09.2.0.0.lBofG8&amp;_u=h4gsni3a18f" target="_blank" rel="external">这里</a>100元左右就能买个带遥控功能的，还有三脚架功能，好神奇。不过用过之后随即就打入冷宫了，后来送给了我哥。</li>
</ul>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>iMovie：苹果操作系统自带的视频编辑软件，功能足够，如果不太熟悉操作，可以移步<a href="http://www.apple.com/cn/ios/imovie/" target="_blank" rel="external">这里</a>先了解下。</li>
<li><a href="https://vimeo.com" target="_blank" rel="external">Vimeo</a>：一个高清视频社区网站，我试过上传优酷，清晰度不好，又尝试秒拍，结果时长有限制。最后只好使用歪果仁的服务了，唯一担心的就是流畅性，试了试，还不错。</li>
</ul>
<h2 id="拍摄地点"><a href="#拍摄地点" class="headerlink" title="拍摄地点"></a>拍摄地点</h2><ul>
<li>天安门广场</li>
<li>故宫</li>
<li>颐和园</li>
<li>圆明园</li>
<li>鸟巢&amp;水立方</li>
<li>地铁&amp;住所&amp;路上</li>
</ul>
<h1 id="最后再说一句"><a href="#最后再说一句" class="headerlink" title="最后再说一句"></a>最后再说一句</h1><p>工具固然要有，但想法和执行更重要。That’s all!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;parents.jpg&quot; alt=&quot;parents&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;去年夏天把父母和奶奶接北京玩了几天，担心奶奶体力问
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="游玩" scheme="http://zerosoul.github.io/tags/%E6%B8%B8%E7%8E%A9/"/>
    
      <category term="iphone6" scheme="http://zerosoul.github.io/tags/iphone6/"/>
    
      <category term="iMovie" scheme="http://zerosoul.github.io/tags/iMovie/"/>
    
      <category term="北京" scheme="http://zerosoul.github.io/tags/%E5%8C%97%E4%BA%AC/"/>
    
      <category term="歪果仁" scheme="http://zerosoul.github.io/tags/%E6%AD%AA%E6%9E%9C%E4%BB%81/"/>
    
      <category term="vimeo" scheme="http://zerosoul.github.io/tags/vimeo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo升级之坑</title>
    <link href="http://zerosoul.github.io/2016/06/15/upgrade-hexo-to-3-2/"/>
    <id>http://zerosoul.github.io/2016/06/15/upgrade-hexo-to-3-2/</id>
    <published>2016-06-15T06:51:43.000Z</published>
    <updated>2016-06-19T15:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="crazy.jpg" alt="crazy"></p>
<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>好久没去<a href="https://hexo.io" target="_blank" rel="external">Hexo官网</a>逛逛了，陡然发现有<a href="https://hexo.io/news/2016/02/28/hexo-3-2-released/" target="_blank" rel="external">新版本</a>了，其重要的改进在于生成静态文件的速度，对于文章越写越多，生成时间越来越长的我，是个极大的诱惑。作为一个还停留在2.X版本的Hexo党，毅然决然地要尝一下鲜。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>先全局升级<code>hexo-cli</code>：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i hexo-cli -g</div></pre></td></tr></table></figure>
<p> 通过<code>hexo version</code>查看下版本：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">hexo: 3.2.0 //版本号已变</div><div class="line">hexo-cli: 1.0.2</div><div class="line">os: Darwin 15.5.0 darwin x64</div><div class="line">http_parser: 2.7.0</div><div class="line">node: 6.2.1 </div><div class="line">v8: 5.0.71.52</div><div class="line">uv: 1.9.1</div><div class="line">zlib: 1.2.8</div><div class="line">ares: 1.10.1-DEV</div><div class="line">icu: 57.1</div><div class="line">modules: 48</div><div class="line">openssl: 1.0.2h</div></pre></td></tr></table></figure>
<p> 注：我的node版本略高，不建议使用高版本，因为经常踩坑，5就足够了。当然，可以使用nvm工具来管理node版本。</p>
</li>
<li><p>找个风水宝地，初始化一个新版本的hexo博客目录：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init new_blog &amp;&amp; cd new_blog &amp;&amp; npm i &amp;&amp; hexo s</div></pre></td></tr></table></figure>
</li>
<li><p>访问下<code>http://localhost:4000</code>，确认下初始化成功了么。正常的话，看到的是默认主题的首页。</p>
</li>
<li><p>把原博客目录<code>source</code>下的东西全部拷贝到新目录对应位置上。这是关键的一步，相当于迁移数据源。</p>
</li>
<li>接下来，是容易踩坑的地方了，不要把原Hexo的配置文件<code>_config.yml</code>直接覆盖过来，因为新版本的Hexo有些插件不走配置文件了，容易出错。所以我在踩了这个坑之后，索性基于新<code>_config.yml</code>来更新对应值，至于插件的配置，全部放弃。</li>
<li>接下来，是主题的更新，我使用的是<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">Next</a>。发现这个也有新版本了，索性一起更新了。具体步骤请参照<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">这里</a>。另，原有主题我更改了一些地方，又花了点时间把琐碎的增量更改也做了。</li>
<li>接下来，<code>hexo g</code>一下，发现有报错，看了下报错信息和我使用<a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="external"><code>hexo-qiniu-sync</code></a>插件有关，于是把七牛插件给装上：<code>npm install hexo-qiniu-sync --save</code>。注意，别忘了更新<code>_config.yml</code>对应的配置，这个可以从原来的地方拷贝过来。</li>
<li><p>另外，我还用到了两个插件<code>hexo-generator-sitemap</code>，<code>hexo-generator-feed</code>，一行代码搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i hexo-generator-sitemap hexo-generator-feed --save</div></pre></td></tr></table></figure>
</li>
<li><p>下面到了最坑的地方了，平时使用<code>hexo-browsersync</code>来边写边看效果，所以升级后自然也得想着它。装上这个插件在我的环境下会导致大部分页面白板，动画效果也没有了。查看了下生成的页面代码，底部有乱码。估计是我的node版本太高导致的，使用nvm降到5，问题依旧。然后去插件<a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="external">Github地址</a>逛逛有没有遇到类似问题的同学，很遗憾，就四个提问题的，和我遇到的问题无关。转变思路，看看是不是版本依赖问题，<code>hexo-browsersync</code>最重要的依赖便是<code>browsersync</code>，将其升级到最新版本：修改该模块的<code>package.json</code>对应的<code>browsersync</code>版本号为<code>*</code>，然后<code>npm update --save</code>。接下来，试试问题有没有解决，果然！不出所料！这样做并没有什么卵用…o(╯□╰)o。<br>纠结到最后，还是暂时去掉了这一功能：<code>npm uninstall hexo-browsersync --save</code>。以后会看一下里面源码，看看到底哪儿的问题。而现在，我需要的就是一个可以写文章和发布的Hexo，虽然用起来不是很便捷，但这已足够了。</p>
</li>
<li><p>最后：<code>npm i --save hexo-deployer-git</code>，配置下<code>_config.yml</code>对应的git选项。</p>
</li>
</ol>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>断断续续折腾了两天，才升级成功。所以，如果有啥感想，那就是：<strong>没事别瞎TM升级！</strong>当然，如果一定要升级，最好做增量升级：另起炉灶，一项一项地加功能，这样好定位问题，也容易回滚。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;crazy.jpg&quot; alt=&quot;crazy&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h1&gt;&lt;p&gt;好久没去&lt;a href=&quot;https://hexo.io&quot;
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://zerosoul.github.io/tags/hexo/"/>
    
      <category term="升级" scheme="http://zerosoul.github.io/tags/%E5%8D%87%E7%BA%A7/"/>
    
      <category term="折腾" scheme="http://zerosoul.github.io/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>React Native之美：构建我的第一个iOS APP（2）</title>
    <link href="http://zerosoul.github.io/2016/06/07/building-my-first-ios-app-with-react-native-part-two/"/>
    <id>http://zerosoul.github.io/2016/06/07/building-my-first-ios-app-with-react-native-part-two/</id>
    <published>2016-06-07T02:50:49.000Z</published>
    <updated>2016-06-19T08:43:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="rn.png" alt="React Native"></p>
<h1 id="再续前缘"><a href="#再续前缘" class="headerlink" title="再续前缘"></a>再续前缘</h1><p><a href="http://zerosoul.github.io/2016/06/05/building-my-first-ios-app-with-react-native-part-one/">第一篇文章</a>，我们从零开始，一步一步走到最后，构建了一个似乎并没有卵用的APP。但是，我们做了大量的基础工作，不就是为了在接下来的继续更轻松自信些嘛！<br><img src="zdw.jpg" alt="wtf"><br>其实，第一篇的信息量还是很大的，里面的每一个链接都是通往一个新知的大门，如果你觉得掌握得差不多了，那就开始新的旅（Che）程（Dan）吧！<br><img src="haha.png" alt="你懂的"><br>第二篇文章也是分五小节叙述，每一节完成一个小功能，最终召唤出还算有点卵用的APP。</p>
<h1 id="1-召唤出壁纸和作者"><a href="#1-召唤出壁纸和作者" class="headerlink" title="1.召唤出壁纸和作者"></a>1.召唤出壁纸和作者</h1><p>首先，我们先研究下数据，下面是从<a href="https://unsplash.it/list" target="_blank" rel="external">Unsplash</a>获取的一个数据实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    author:&quot;Ben Moore&quot;</div><div class="line">    author_url:&quot;https://unsplash.com/@benmoore&quot;</div><div class="line">    filename:&quot;0102_pJILiyPdrXI.jpeg&quot;</div><div class="line">    format:&quot;jpeg&quot;</div><div class="line">    height:3240</div><div class="line">    id:102</div><div class="line">    post_url:&quot;https://unsplash.com/photos/pJILiyPdrXI&quot;</div><div class="line">    width:4320 </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要想获取该实例的图片，在浏览器中输入以下格式的URL<code>http://unsplash.it/{width}/{height}?image={id}</code>，换算到该实例即：<a href="http://unsplash.it/4320/3240?image=102" target="_blank" rel="external"><code>http://unsplash.it/4320/3240?image=102</code></a>。这样，我们就能拿到一张壁纸的地址了。我们可以用<code>Image</code>组件中的<code>source</code>来把图片加载出来。</p>
<p>但是，进一步想了想，这么大的图片会有一定的加载时间，最好能有个图片的加载进度什么的，让用户不再一脸懵逼地等着。一开始就做对，后面的修改成本会小很多，有两个组件的组合能够做到预期效果：</p>
<p><a href="https://github.com/oblador/react-native-image-progress" target="_blank" rel="external"><strong>image-native-progress</strong></a>和<a href="https://github.com/oblador/react-native-progress" target="_blank" rel="external"><strong>react-native-progress</strong></a>。</p>
<p>在项目根目录下运行命令：<code>npm i --save react-native-image-progress react-native-progress</code>，然后，我们在<strong>index.ios.js</strong>中引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var NetworkImage = require(&apos;react-native-image-progress&apos;);</div><div class="line">var Progress = require(&apos;react-native-progress&apos;);</div></pre></td></tr></table></figure></p>
<p>既然要做手机壁纸应用，那么就应该得到手机屏幕的长和宽：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var &#123;width, height&#125; = React.Dimensions.get(&apos;window’);</div></pre></td></tr></table></figure></p>
<p>哦对了，为了去掉烦人的<code>React.Dimensions</code>，可以在头部引入<code>Dimensions</code>组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  ActivityIndicatorIOS,</div><div class="line">  /***/</div><div class="line">  Dimensions </div><div class="line">  /***/</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>
<p>这样，我们就可以在<code>renderResults</code>中使用<code>NetworkImage</code>了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Swiper ... &gt;</div><div class="line">  &#123;wallsJSON.map((wallpaper, index) =&gt; &#123;</div><div class="line">    return(</div><div class="line">    /***/</div><div class="line">      &lt;View key=&#123;index&#125;&gt;</div><div class="line">        &lt;NetworkImage</div><div class="line">          source=&#123;&#123;uri: `https://unsplash.it/$&#123;wallpaper.width&#125;/$&#123;wallpaper.height&#125;?image=$&#123;wallpaper.id&#125;`&#125;&#125;</div><div class="line">          indicator=&#123;Progress.Circle&#125;</div><div class="line">          style=&#123;styles.wallpaperImage&#125;&gt;</div><div class="line">        &lt;/NetworkImage&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    /***/</div><div class="line">    ); </div><div class="line">  &#125;)&#125;</div><div class="line">&lt;/Swiper&gt;</div></pre></td></tr></table></figure></p>
<p><strong>注：此处<code>NetworkImage</code>的<code>uri</code>特性用到了ES6的模板字符串特性，懵逼的同学去<a href="http://zerosoul.github.io/2016/06/05/building-my-first-ios-app-with-react-native-part-one/#先谈谈需求">上一篇文章</a>找链接复习一下哈。</strong></p>
<p>再加个样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wallpaperImage: &#123;</div><div class="line">  flex: 1,</div><div class="line">  width: width,</div><div class="line">  height: height,</div><div class="line">  backgroundColor: ‘#000’</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存然后刷新模拟器，不出意外的话…你将看到一堆报错的页面。<br><img src="long.jpg" alt="成龙"><br>别慌，我们来研究下刚刚加的代码，注意到<code>indicator={Progress.Circle}</code>没有？在<code>react-native-progress</code>文档里有提到（别告诉我你没看<a href="https://github.com/oblador/react-native-progress" target="_blank" rel="external">文档</a>(╯‵□′)╯︵┻━┻），<code>Progress.Circle</code>需要<strong>ReactART</strong>：使用React来画矢量图的类库。我们不需要下载任何新东西，只需要通过Xcode将其引入到项目中。<br>很简单，只是有点繁琐：</p>
<ol>
<li>移步 <code>node_modules/react-native/Libraries/ART/</code><br><img src="dir.png" alt="art目录"></li>
<li>将<em>ART.xcodeproj</em>拖拽到Xcode的<em>PIW/Libraries</em>下<br><img src="libs.png" alt="libs"></li>
<li>定位到<em>Build Phases</em>，友情提示：它与<em>General</em>,<em>Capabilities</em>等同级。<br><img src="buildphase.png" alt=""></li>
<li>将<em>ART.xcodeproj/Products</em>下的<em>libART.a</em>拖拽到<em>Build Phases</em>下的<em>Link Binary With Libraries</em>条目下：<br><img src="linklib.png" alt=""></li>
</ol>
<p>就这么简单，全是些拖拖拽拽的活儿。</p>
<p>然后，刷新模拟器。酷！我们已经能够看到带加载进度的壁纸，并且能左右滑动浏览。有没有碰到心动的图片？载下来？莫慌，待会儿来满足你。现在，我们先修改下进度提示的样式，这个在<code>NetworkImage</code>下的<code>indicatorProps</code>可以设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;NetworkImage</div><div class="line">  source=&#123;&#123;uri: `https://unsplash.it/$&#123;wallpaper.width&#125;/$&#123;wallpaper.height&#125;?image=$&#123;wallpaper.id&#125;`&#125;&#125;</div><div class="line">  indicator=&#123;Progress.Circle&#125;</div><div class="line">  style=&#123;styles.wallpaperImage&#125;&gt;</div><div class="line">  /***/</div><div class="line">  indicatorProps=&#123;&#123;</div><div class="line">    color:&apos;rgba(255,255,255,0.8)&apos;,</div><div class="line">    size:50,</div><div class="line">    thickness:4</div><div class="line">  &#125;&#125;</div><div class="line">  /***/</div><div class="line">&lt;/NetworkImage&gt;</div></pre></td></tr></table></figure></p>
<p>修改后进度提示应该长这样：<br><img src="indicator.png" alt="indicator"></p>
<p>接下来，把图片的作者名字加上，我们要做尊重知识版权的好公民：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;NetworkImage</div><div class="line">...</div><div class="line">&gt;</div><div class="line">/***/</div><div class="line">    &lt;Text style=&#123;styles.label&#125;&gt;Photo by&lt;/Text&gt;</div><div class="line">    &lt;Text style=&#123;styles.label_author_name&#125;&gt;&#123;wallpaper.author&#125;&lt;/Text&gt;</div><div class="line">/***/</div><div class="line">&lt;/NetworkImage&gt;</div></pre></td></tr></table></figure></p>
<p>别忘了创建各自对应的样式对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">label:&#123;</div><div class="line">    position:&apos;absolute&apos;,</div><div class="line">    color:&apos;#fff&apos;,</div><div class="line">    fontSize:13,</div><div class="line">    backgroundColor:&apos;#000&apos;,</div><div class="line">    padding:5,</div><div class="line">    paddingLeft:8,</div><div class="line">    top:20,</div><div class="line">    left:20</div><div class="line">  &#125;,</div><div class="line">label_author_name:&#123;</div><div class="line">    position:&apos;absolute&apos;,</div><div class="line">    color:&apos;#fff&apos;,</div><div class="line">    fontSize:15,</div><div class="line">    backgroundColor:&apos;#000&apos;,</div><div class="line">    padding:5,</div><div class="line">    paddingLeft:8,</div><div class="line">    top:52,</div><div class="line">    left:20,</div><div class="line">    fontWeight:&apos;bold&apos;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>来来来，我们瞅瞅加了作者后的效果：<br><img src="withauthor.png" alt=""></p>
<p>有木有瞬间感觉像那么回事儿了！<br><img src="dese.png" alt=""></p>
<p>走到这儿，这一节算完事儿了，为了能下载壁纸，我们将在下一节做一些更加有技术含量的事儿。</p>
<h1 id="2-捕捉双击操作-Double-Taps"><a href="#2-捕捉双击操作-Double-Taps" class="headerlink" title="2. 捕捉双击操作(Double-Taps)"></a>2. 捕捉双击操作(Double-Taps)</h1><p>这一节我们要用到的是PanResponder，这个API能做一些很酷的事情，比如捕捉双击操作。</p>
<p>其实，如果偷懒，完全可以在页面上放一个下载按钮，点击就下载，完活儿！但是，我们要做就做有逼格的事儿，双击图片下载就很符合这个档次，恩，撸起袖子干吧！</p>
<p>在开始之前，最好阅读一遍<a href="https://facebook.github.io/react-native/docs/panresponder.html" target="_blank" rel="external">PanResponder API</a>文档，因为你不读一遍，也不知道这个文档其实也没啥卵用o(╯□╰)o。不过我们至少知道了PanResponder的基本用法，这就够了。</p>
<p>废话少说，开始撸代码。首先，在构造函数里声明一个新对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.imagePanResponder = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>别忘了在顶部引入<code>PanResponder</code>的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  ActivityIndicatorIOS,</div><div class="line">  /***/</div><div class="line">  PanResponder</div><div class="line">  /***/</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>
<p>接下来我们要做两件事：</p>
<ul>
<li>创建一个<code>PanResponder</code>并赋值<code>imagePanResponder</code></li>
<li>将<code>imagePanResponder</code>关联到<code>&lt;NetworkImage&gt;</code>组件</li>
</ul>
<p>为了完成第一件事，需要新增一个生命周期函数:<code>componentWillMount</code>。这个函数只有在组件首次渲染时才会触发，所以非常适合用于初始化<code>PanResponder</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">componentWillMount() &#123;</div><div class="line">    this.imagePanResponder = PanResponder.create(&#123;</div><div class="line">      onStartShouldSetPanResponder: this.handleStartShouldSetPanResponder,</div><div class="line">      onPanResponderGrant: this.handlePanResponderGrant,</div><div class="line">      onPanResponderRelease: this.handlePanResponderEnd,</div><div class="line">      onPanResponderTerminate: this.handlePanResponderEnd</div><div class="line">    &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>初始化完了，就可以将这些事件关联到<code>NetworkImage</code>组件了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line"> &#123;...this.imagePanResponder.panHandlers&#125;&gt;</div></pre></td></tr></table></figure>
<p>注：<code>...</code>是ES6中的扩展运算符，如果懵逼，请移步<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">这里</a>充电。</p>
<p>一般来说，一个触摸事件有三个阶段：开始（start）、移动（move）、释放（release），一个组件能够通过声明响应特定的触摸事件。<code>PanResponder.create({...</code>下提到的第一个事件<code>onStartShouldSetPanResponder</code>，从英文名字的意思大概也能猜出，这是在请求是否能将<code>PanResponder</code>绑定在该组件上。紧跟其后是一个方法<code>this.handleOnStartShouldSetPanResponder</code>，用于响应该事件，若该方法返回<code>true</code>，则通过请求，然后才能谈下一步，<code>false</code>则相反。所以，你应该知道在此我们应该返回什么，认清你的阶级立场，同志，老大哥在看着你：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handleStartShouldSetPanResponder(e, gestureState) &#123;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>紧随其后的<code>onPanResponderGrant</code>是在一旦有了触摸时触发，在此我们先打印一个信息占个坑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handlePanResponderGrant()&#123;</div><div class="line">    console.log(&quot;手指触摸到屏幕啦~~~&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最后两个事件从字面上也都能自解释，在手指离开屏幕时，都能触发，在此我们还是先打印信息占个坑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">handlePanResponderEnd()&#123;</div><div class="line">    console.log(&quot;手指离开屏幕啦~~~&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>保存代码，壁纸一旦加载完毕，点击一下，应该会看到如下打印信息：<br><img src="touched.png" alt=""></p>
<p>OK，基于这些认知，我们可以开始捕捉双击操作了。判断是否为双击操作的关键是需要知道上一操作的信息：触摸发生的<strong>坐标</strong>和<strong>时间戳</strong>。在构造函数新增对象<code>prevTouchInfo</code>用于保存触摸信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">this.prevTouchInfo = &#123;</div><div class="line">  X: 0,</div><div class="line">  Y: 0,</div><div class="line">  timeStamp: 0</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后，在<code>handlePanResponderGrant</code>更新这个对象(注意代码的次序)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">handlePanResponderGrant(e, gestureState) &#123;</div><div class="line">/***/</div><div class="line">  var currentTouchTimeStamp = Date.now();</div><div class="line"></div><div class="line">  if( this.isDoubleTap(currentTouchTimeStamp, gestureState) ) </div><div class="line">    console.log(&apos;双击操作&apos;);</div><div class="line"></div><div class="line">  this.prevTouchInfo = &#123;</div><div class="line">    X: gestureState.x0,</div><div class="line">    Y: gestureState.y0,</div><div class="line">    timeStamp: currentTouchTimeStamp</div><div class="line">  &#125;;</div><div class="line">/***/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>handlePanResponderGrant</code>在每次单击时都会触发，但是有个地方需要特别注意：此处的<code>this</code>并不是指向<code>PIW</code>类，而是<code>PanResponder</code>，为了正确的引用，我们需要在构造函数使用<code>bind</code>重新定向一下。而如果我们一开始选用<code>React.createClass({ ... })</code>来创建组件，就不会存在这个问题，<strong>autobinding</strong>会帮我们搞定这个问题。也算有得有失吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.handlePanResponderGrant = this.handlePanResponderGrant.bind(this);</div></pre></td></tr></table></figure>
<p><code>isDoubleTap</code>是我们预先埋好的坑，下面我们填上它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">isDoubleTap(currentTouchTimeStamp, &#123;x0, y0&#125;) &#123;</div><div class="line">  var &#123;X, Y, timeStamp&#125; = this.prevTouchInfo;</div><div class="line">  var dt = currentTouchTimeStamp - timeStamp;</div><div class="line"></div><div class="line">  return (dt &lt; DOUBLE_TAP_DELAY &amp;&amp; Utils.distance(X, Y, x0, y0) &lt; DOUBLE_TAP_RADIUS);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好吧，你可能会注意到了，坑里有坑：</p>
<ul>
<li><p><code>DOUBLE_TAP_DELAY</code>和<code>DOUBLE_TAP_RADIUS</code>是我们定义的常量，需要在头部初始化一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const DOUBLE_TAP_DELAY = 400; // milliseconds</div><div class="line">const DOUBLE_TAP_RADIUS = 20;</div></pre></td></tr></table></figure>
</li>
<li><p>新建一个模块<strong>utils.js</strong>，暴露出<code>distance</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">distance(x0, y0, x1, y1) &#123;</div><div class="line">  return Math.sqrt( Math.pow(( x1 - x0 ), 2) + Math.pow(( y1 - y0 ), 2) );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><code>distance</code>是用来计算两个坐标之间的直线距离，还记得中学的几何公式吗？<br><img src="distance.png" alt="distance"></p>
<p><code>handlePanResponderGrant</code>最后一步是更新<code>prevTouchInfo</code>。</p>
<p>保存代码，等壁纸加载完毕，双击屏幕，如果不出意外的话，控制台里会输出:<strong>双击操作</strong>。</p>
<h1 id="3-将壁纸保存到本地相册"><a href="#3-将壁纸保存到本地相册" class="headerlink" title="3.将壁纸保存到本地相册"></a>3.将壁纸保存到本地相册</h1><p>现在我们能捕捉到双击的手势了，也就可以开始着手撸保存壁纸的代码了。首先，我们把console代码替换成一个调用的方法，先占坑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if( isDoubleTap(currentTouchTimeStamp, gestureState) )</div><div class="line">  this.saveCurrentWallpaperToCameraRoll();</div></pre></td></tr></table></figure></p>
<p>一会儿我们再来实现<code>saveCurrentWallpaperToCameraRoll</code>，下面我们先来看另一个问题：壁纸有五张，如何定位当前的这一张？<br>我们可以通过从零开始的索引来定位当前图片，每滑动一次就加1或者减1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.currentWallIndex = 0;</div></pre></td></tr></table></figure></p>
<p>还记得上一篇我们预留的一个坑位吗？<code>Swiper</code>里的<code>onMomentumScrollEnd</code>，在该方法里更新<code>currentWallIndex</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">onMomentumScrollEnd(e, state, context) &#123;</div><div class="line">  this.currentWallIndex = state.index;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的，别忘了在<code>constructor</code>里绑定<code>this</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.onMomentumScrollEnd = this.onMomentumScrollEnd.bind(this);</div></pre></td></tr></table></figure>
<p>好了，我们开始为<code>saveCurrentWallpaperToCameraRoll</code>填坑了。为了能访问相册，需要先引入<code>Camera Roll</code>类库，还记得开头是怎么引入<code>ReactART</code>的吗？没错，照做一遍就可以：<code>node_modules/react-native/Libraries/CameraRoll</code><br><img src="cameraroll.png" alt=""></p>
<p>然后就可以导入了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  View,</div><div class="line">  Text,</div><div class="line">  StyleSheet,</div><div class="line">  Dimensions,</div><div class="line">  PanResponder,</div><div class="line">  /***/</div><div class="line">  CameraRoll, // 访问相册</div><div class="line">  AlertIOS // iOS的弹出框</div><div class="line">  /***/</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>
<p>一旦壁纸保存到相册，我们需要给用户一个保存成功的提示，<code>AlertIOS</code>帮我们做到这一点。现在，我们可以着手实现<code>saveCurrentWallpaperToCameraRoll</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">saveCurrentWallpaperToCameraRoll() &#123;</div><div class="line">  var &#123;wallsJSON&#125; = this.state;</div><div class="line">  var currentWall = wallsJSON[this.currentWallIndex];</div><div class="line">  var currentWallURL = `http://unsplash.it/$&#123;currentWall.width&#125;/$&#123;currentWall.height&#125;?image=$&#123;currentWall.id&#125;`;</div><div class="line"></div><div class="line">  CameraRoll.saveImageWithTag(currentWallURL)</div><div class="line">  .then((data) =&gt; &#123;</div><div class="line">    AlertIOS.alert(</div><div class="line">      &apos;保存成功&apos;,</div><div class="line">      &apos;壁纸已保存到本地相册&apos;,</div><div class="line">      [</div><div class="line">        &#123;text: &apos;好哒!&apos;, onPress: () =&gt; console.log(&apos;OK Pressed!&apos;)&#125;</div><div class="line">      ]</div><div class="line">    );</div><div class="line">  &#125;)</div><div class="line">  .catch((err) =&gt;&#123;</div><div class="line">    console.log(&apos;Error saving to camera roll&apos;, err);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码都能做到自解释，不懂的地方移步：<a href="https://facebook.github.io/react-native/docs/cameraroll.html" target="_blank" rel="external">CameraRoll</a>和<a href="https://facebook.github.io/react-native/docs/alertios.html" target="_blank" rel="external">AlertIOS</a>，你懂的。</p>
<p>好啦，保存代码，去模拟器体验一下保存壁纸功能：（首次保存需要手动同意获取访问相册的权限）<br><img src="saved.png" alt=""><br>完美！额，等等，从双击到壁纸保存成功，好像有那么几秒的等待时间，用户可能会认为双击不成功，然后再双击一次，这不是我们的期望，下一节专门解决这个问题！</p>
<h1 id="4-创建一个等待组件：Waiting-js"><a href="#4-创建一个等待组件：Waiting-js" class="headerlink" title="4.创建一个等待组件：Waiting.js"></a>4.创建一个等待组件：Waiting.js</h1><p>如果没记错的话，我们将创建第一个组件：Waiting.js。这个组件用于异步操作的等待时间，比如保存壁纸到相册的操作，就很有必要加一个等待提示，让用户知道APP在做什么。</p>
<p>在项目根目录新建文件：<strong>Waiting.js</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">import &#123;</div><div class="line">  View,</div><div class="line">  Text,</div><div class="line">  Component,</div><div class="line">  ActivityIndicatorIOS,</div><div class="line">&#125; from &apos;react-native&apos;;</div><div class="line"></div><div class="line">class default Waiting extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props); </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    var &#123;width, height, isVisible&#125; = this.props;</div><div class="line">    if( isVisible ) &#123;</div><div class="line">      return(</div><div class="line">        &lt;View </div><div class="line">         style=&#123;&#123;</div><div class="line">          flex: 1,</div><div class="line">          flexDirection: &apos;row&apos;,</div><div class="line">          justifyContent: &apos;center&apos;,</div><div class="line">          alignItems: &apos;center&apos;,</div><div class="line">          width: width,</div><div class="line">          height: height,</div><div class="line">          position: &apos;absolute&apos;,</div><div class="line">          top: 0,</div><div class="line">          left: 0,</div><div class="line">          backgroundColor: &apos;rgba(0, 0, 0, 0.5)&apos;</div><div class="line">         &#125;&#125;&gt;</div><div class="line">         &lt;ActivityIndicatorIOS</div><div class="line">            animating=&#123;true&#125;</div><div class="line">            color=&#123;&apos;#fff&apos;&#125;</div><div class="line">            size=&#123;&apos;large&apos;&#125; </div><div class="line">            style=&#123;&#123;margin: 15&#125;&#125; /&gt;</div><div class="line">           &lt;Text style=&#123;&#123;color:’#fff’&#125;&#125;&gt;正在保存，请稍后...&lt;/Text&gt;</div><div class="line">        &lt;/View&gt; </div><div class="line">      );</div><div class="line">    &#125; else &#123;</div><div class="line">      return(&lt;View&gt;&lt;/View&gt;);</div><div class="line">    &#125;</div><div class="line">  &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">module.exports = Waiting;</div></pre></td></tr></table></figure></p>
<p><code>render</code>第一行代码作用是从组件的<code>props</code>中获取相应的属性，其中<code>isVisible</code>用于判断是否显示该组件，使用该组件的格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Waiting width=&#123;width&#125; height=&#123;height&#125; isVisible=&#123;isWaitingVisible&#125;/&gt;</div></pre></td></tr></table></figure></p>
<p>在<strong>index.ios.js</strong>中引入<strong>Waiting.js</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var Waiting = require(&apos;./Waiting.js&apos;);</div></pre></td></tr></table></figure></p>
<p>为了能控制Waiting组件的显示与隐藏，需要在<strong>index.ios.js</strong>新增一个状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">this.state = &#123;</div><div class="line">  wallsJSON: [],</div><div class="line">  isLoading: true,</div><div class="line">/***/</div><div class="line">  isWaitngVisible: false // 默认不显示</div><div class="line">/***/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>现在，我们可以在<code>&lt;/Swiper</code>之后放入<code>&lt;Waiting&gt;</code>组件了，不过，直接这样做会导致报错，因为<a href="https://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html" target="_blank" rel="external">React不允许返回多个组件</a>。为了解决这个问题，我们需要用<code>&lt;View&gt;&lt;/View&gt;</code>再做一个简单的包裹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">renderResults() &#123;</div><div class="line">  var &#123;wallsJSON, isWaitngVisible&#125; = this.state;</div><div class="line">  return (</div><div class="line">  /***/</div><div class="line">    &lt;View&gt;</div><div class="line">  /***/</div><div class="line">    &lt;Swiper</div><div class="line">      ...&gt;</div><div class="line"></div><div class="line">.</div><div class="line">.</div><div class="line">.</div><div class="line">    &lt;/Swiper&gt;</div><div class="line">  /***/</div><div class="line">    &lt;Waiting width=&#123;width&#125; height=&#123;height&#125; isVisible=&#123;isWaitngVisible&#125;/&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">  /***/</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>既然有了<code>isWaitngVisible</code>状态，我们就应该想一想在哪些时机来改变它的状态：双击触发时置为<code>true</code>，保存成功时置为<code>false</code>，对应到代码就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">saveCurrentWallpaperToCameraRoll() &#123;</div><div class="line"></div><div class="line">/***/</div><div class="line">  // Waiting 组件显示</div><div class="line">  this.setState(&#123;isWaitingVisible: true&#125;);</div><div class="line">/***/</div><div class="line"></div><div class="line">  var &#123;wallsJSON&#125; = this.state;</div><div class="line">  var currentWall = wallsJSON[this.currentWallIndex];</div><div class="line">  var currentWallURL = `http://unsplash.it/$&#123;currentWall.width&#125;/$&#123;currentWall.height&#125;?image=$&#123;currentWall.id&#125;`;</div><div class="line"></div><div class="line">  CameraRoll.saveImageWithTag(currentWallURL, (data) =&gt; &#123;</div><div class="line"></div><div class="line">/***/</div><div class="line">    // Waiting 组件隐藏</div><div class="line">    this.setState(&#123;isWaitingVisible: false&#125;);</div><div class="line">/***/</div><div class="line"></div><div class="line">    AlertIOS.alert(</div><div class="line">      &apos;保存成功&apos;,</div><div class="line">      &apos;壁纸已保存到本地相册&apos;,</div><div class="line">      [</div><div class="line">        &#123;text: &apos;好哒！&apos;, onPress: () =&gt; console.log(&apos;OK Pressed!&apos;)&#125;</div><div class="line">      ]</div><div class="line">    );</div><div class="line">  &#125;,(err) =&gt;&#123;</div><div class="line">    console.log(&apos;Error saving to camera roll&apos;, err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>模拟器刷新，双击壁纸，等待组件出现，稍后保存成功的弹窗出现，等待组件消失，完美！</p>
<p>额，等等，真的很完美吗？有没有注意到保存完图片，屏幕跳到了第一张图片。这是因为我们在<code>saveWallpaperToCameraRoll</code>调用<code>this.setState()</code>，改变了<code>isWaitingVisible</code>的状态，触发了<code>render()</code>，从而<code>swiper</code>重新加载数据并从第一张图显示。</p>
<p>为了解决这个bug，我们可以通过<code>Swiper</code>的<code>index</code>入手：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Swiper ...</div><div class="line">        index=&#123;this.currentWallIndex&#125;&gt;</div></pre></td></tr></table></figure></p>
<p>这样，就保证了每次重新渲染，都从保存的那张开始。<br><img src="saving.png" alt="saving"><br>好了，写到这里，我们基本完工一个核心功能完备的小应用：</p>
<ul>
<li>能加载随机精美壁纸</li>
<li>能浏览</li>
<li>能保存</li>
</ul>
<p>如果对随机的五张壁纸无感，想换一批，怎么破？当然，我们可以放置一个按钮，点击便能更新随机的壁纸数据，可是…能不能做得酷一些呢？比如只需要摇一摇手机，便更新了一批壁纸！</p>
<p>年轻人，下一节我们做这件酷酷的事儿…<br><img src="maomi.jpg" alt=""></p>
<h1 id="5-摇一摇动作（Shake）和真机测试"><a href="#5-摇一摇动作（Shake）和真机测试" class="headerlink" title="5.摇一摇动作（Shake）和真机测试"></a>5.摇一摇动作（Shake）和真机测试</h1><p>为了使我们的APP能够捕捉到摇一摇的动作，需要新增一个模块：<a href="https://www.npmjs.com/package/react-native-shake-event-ios" target="_blank" rel="external">react-native-shake-event-ios</a>。项目根目录运行：<code>npm install --save react-native-shake-event-ios</code>。</p>
<p>另外，我们还需要做的是链接相应的类库。如果没记错的话，这是第三次，也是最后一次做这样的操作，我就不多说了，应该熟练了，少年。温馨提示：<code>node_modules/react-native-shake-event-ios/</code>下的<code>RNShakeEvent.xcodeproj</code></p>
<p>引用该类库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ShakeEvent = require(&apos;react-native-shake-event-ios&apos;);</div></pre></td></tr></table></figure></p>
<p>我们在<code>componentWillMount</code>新增摇一摇的监听动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">componentWillMount() &#123;</div><div class="line">  ...</div><div class="line">/***/</div><div class="line">  // 摇一摇，更新数据</div><div class="line">  ShakeEvent.addEventListener(&apos;shake&apos;, () =&gt; &#123;</div><div class="line">    this.initialize();</div><div class="line">    this.fetchWallsJSON();</div><div class="line">  &#125;);</div><div class="line">/***/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>initialize</code>填坑，其实就是初始化各种状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">initialize() &#123;</div><div class="line">  this.setState(&#123;</div><div class="line">    wallsJSON: [],</div><div class="line">    isLoading: true,</div><div class="line">    isWaitingVisible: false</div><div class="line">  &#125;);</div><div class="line">  this.currentWallIndex = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存代码，接下来我们开始真机测试。当然，如果没有真机，也可以通过快捷键组合：<code>CMD + Ctrl + Z</code>模拟摇一摇操作。不过，我还是期望你有一部真机，因为…这样可以拿来装X啊，少年！</p>
<p>真机测试意味着我们将脱离开发环境，像平时通过AppStore安装APP那样把我们的APP放到手机内。按照<a href="https://facebook.github.io/react-native/docs/running-on-device-ios.html#using-offline-bundle" target="_blank" rel="external">官方文档</a>来做，其实很简单：</p>
<ol>
<li><p>找到<code>Xcode/PIW/PIW/AppDeletegate.m</code>，做以下操作：<br><img src="uncomment.png" alt=""></p>
</li>
<li><p><code>Product → Scheme → Edit Scheme</code>或者直接快捷键：<code>CMD + Shift + ,</code>，划入的窗口中将<code>Build Configuration</code>从<code>debug</code>改为<code>Release</code>:<br><img src="schema.png" alt=""><br>这样做的目的是为了防止摇一摇弹出调试菜单。</p>
</li>
<li><p>转向<code>Build Setting</code>，禁掉<code>Dead Code Stripping</code>，别问我这是为啥，我也不清楚，可能这就是人生，年轻人。<br><img src="deadcode.png" alt=""></p>
</li>
</ol>
<p>联接你的iPhone到Mac上，选择真机运行：<br><img src="runmyphone.png" alt=""></p>
<p>好啦，万事俱备，只欠一个点击。首次打包和安装会持续较长时间，请耐心等候。安装过程中甭管蹦出什么，选择<strong>相信</strong>就行。注意，如果想恢复到开发环境，把上面的步骤1和步骤2撤销就可以了。</p>
<p>安装完毕，手机桌面上就应该多出一个巨丑的APP图标，没错，那就是这么长时间我们辛苦做出的APP，快快打开体验一番吧！</p>
<p>最后，我们把图标也加上：</p>
<ol>
<li>下载<a href="http://7xo6wq.com1.z0.glb.clouddn.com/SplashWallIcons.zip" target="_blank" rel="external">图标文件</a>。当然，你也可以自己按照<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/IconMatrix.html" target="_blank" rel="external">苹果图标规定</a>来设计一套</li>
<li>调转到Xcode<code>PIW/PIW/Images.xcassets</code>，选择AppIcon</li>
<li>将图标文件按照规格拖拽到对应的框内，一个萝卜一个坑，so easy!<br><img src="icons.png" alt=""></li>
</ol>
<p>再次打包和运行，这次那个巨丑无比的图标应该不见了。</p>
<p>卧槽，我们目前是不是可以说正式完成了一个APP版本的迭代？是的，我们做到了！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>又到了总结时间了，这一次我们都做了哪些事情呢：</p>
<ul>
<li><code>NetworkImage</code>组件让我们能够显示出带加载进度的图片</li>
<li><code>PanResponder</code>API让我们能够捕捉到双击操作</li>
<li><code>Camera Roll</code>让我们能够将壁纸保存到本地相册</li>
<li><code>Waiting</code>是我们首个自定义的组件，让用户在保存壁纸的同时不再懵逼</li>
<li><code>react-native-shake-event-ios</code>让我们能够检测到摇一摇操作，并在恰当的时机，更新随机数据</li>
</ul>
<p>目前为止，我们已经完成了一个功能较完备的APP，同时也学习了许多新知，没有过多地深入，但均给出了深入的入口，也就是文章中的链接。其实，这个APP还可以加入许多好玩的特性，比如：</p>
<ul>
<li>既然有双击操作，是不是可以考虑加一个单击操作：单击壁纸，隐藏顶部的两个小黑条和底部的分页，也就是全屏显示壁纸，看得更爽一些，再次单击，恢复隐藏的元素。</li>
<li>有没有可能做一个设置壁纸前的预览功能呢？虽然可能从API上有所限制，但我们可以通过一些hack的方式来达到类似的目的，至于什么方式，发挥你的脑洞去试试吧。</li>
<li>每次打开APP都要从第三方获取数据，对于在非WiFi环境，用户可能会有所顾虑，是不是应该做一个本地缓存第三方数据的功能，甚至图片？</li>
<li>现在我们的代码组织并不很模块化，这一点可不可以做些优化？</li>
<li>React Native 也可以做安卓开发，尝尝鲜？</li>
</ul>
<p>以上是我能想到的一些功能点和优化点，如果我们能一步一步走到现在，相信这些好玩的特性也不会那么难实现。或许，我还会写个番外篇，讲一讲如何继续迭代<strong>PIW</strong>。</p>
<p>通过这个简单的APP，我们接触到了许多知识点，但React Native的学习远不止这些，一些高级话题我们还没涉猎，比如<code>Flux/Redux</code>。但万变不离阅读官方文档，加之实例练习，边学边总结，是我的节奏。Hey，man，你的节奏找到了吗？好了，我累了，打烊了…<br><img src="tired.jpg" alt="姚明"><br>哦对了，最新代码放在了<a href="https://github.com/zerosoul/PIW" target="_blank" rel="external">Github上</a>，欢迎指正。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.smashingmagazine.com/2016/04/how-to-build-your-first-ios-app-with-javascript/#" target="_blank" rel="external">The Beauty Of React Native: Building Your First iOS App With JavaScript (Part 2)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;rn.png&quot; alt=&quot;React Native&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;再续前缘&quot;&gt;&lt;a href=&quot;#再续前缘&quot; class=&quot;headerlink&quot; title=&quot;再续前缘&quot;&gt;&lt;/a&gt;再续前缘&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://z
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="react" scheme="http://zerosoul.github.io/tags/react/"/>
    
      <category term="app" scheme="http://zerosoul.github.io/tags/app/"/>
    
      <category term="翻译" scheme="http://zerosoul.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="react native" scheme="http://zerosoul.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>React Native之美：构建我的第一个iOS APP（1）</title>
    <link href="http://zerosoul.github.io/2016/06/05/building-my-first-ios-app-with-react-native-part-one/"/>
    <id>http://zerosoul.github.io/2016/06/05/building-my-first-ios-app-with-react-native-part-one/</id>
    <published>2016-06-05T02:50:49.000Z</published>
    <updated>2016-06-16T06:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="rn.png" alt="React Native"></p>
<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>严格来说这是一篇译文，但与一般的翻译有所不同，我会修正原文中一些小错误，也会指出没有提及的一些坑，还会基于原文的想法做一些扩展开发。所以，读的时候有些是原作者的话，有些是我的添油加醋，但整体绝对保证流畅。另，基于原文改动较多，也就懒得一一标注出来，或许显得有些不负责，但是…<br><img src="ldwy.jpg" alt="来打我呀"><br>好了，下面开始进入正题：<br><img src="zb.jpg" alt="装逼"></p>
<h1 id="之前的困惑"><a href="#之前的困惑" class="headerlink" title="之前的困惑"></a>之前的困惑</h1><p>使用<code>Javascript</code>来构建移动应用已经不是什么新鲜事了。<a href="http://ionicframework.com/" target="_blank" rel="external">Ionic</a>和<a href="http://phonegap.com/" target="_blank" rel="external">Phonegap</a>已经做了大量的探索，建立了各自的开发生态圈，吸引了相当多的开发者，不得不说都获得了一定程度的成功。</p>
<p>但是，尝试做了一些小Demo后，这些框架变得毫无吸引力，主要原因应该是<strong>很难做到原生体验</strong>。后来，转念一想，为啥不使用<code>Swift/Objective-C</code>或者<code>Java</code>构建原生app呢，诚然，这对于从前端开发转向app开发，需要学习的挺多，但这不正是一名现代Web开发者所擅长的吗：快速学习。那么，从哪儿开头呢？在Google过程中遇到了一篇文章：<a href="https://medium.com/ios-os-x-development/an-ios-developer-on-react-native-1f24786c29f0#.avhlz9qsr" target="_blank" rel="external">An iOS Developer on React Native</a>，其中一句话打动了我：</p>
<blockquote>
<p>Fast-forward a couple of months, and I’m confident enough to say I may never write an iOS app in Objective-C or Swift again.（快进几个月，我有足够的信心说：再也不会用Objective-C或者Swift来写iOS app了！）</p>
</blockquote>
<p>一切的遇见都不是偶然的。看来，官方语言也有不少坑，那为啥不选择<code>React Native</code>呢，更何况自己是前端工（Ban）程（Zhuan）师（De）。好吧，我承认绕了个不必要的圈子，但走一些弯路能看到更多的风景，不是吗？<br><img src="ym.png" alt="姚明"><br>好的，下面先了解下需求。（难道不应该是先说一下<code>React Native</code>么 (╯‵□′)╯︵┻━┻）</p>
<h1 id="先谈谈需求"><a href="#先谈谈需求" class="headerlink" title="先谈谈需求"></a>先谈谈需求</h1><p>很不幸，我从未在苹果商店找到过一个设置手机壁纸的完美APP。在Mac上，<a href="http://unsplash.com/" target="_blank" rel="external">Unsplash</a>承包了我的所有这方面的需求，很完美，然而在手机上…对不起，打开<code>Setting</code>，找到<code>Wallpaper</code>…。</p>
<p>为何不试着做一个满足自己需求的APP呢？下面是我目前希望有的功能点：</p>
<ul>
<li>随机展示适合当做手机壁纸的图片</li>
<li>可以滑动浏览</li>
<li>可以保存到相册</li>
<li>保存前可以预览设置后的效果</li>
</ul>
<p>虽然最后一项不知道能否做到，但至少可以开始撸其它功能点了。额，等等，开始之前，我觉得有必要提醒一下你应该知道的事情：</p>
<ul>
<li>Javascript</li>
<li>一些<code>ES6</code>的特性：<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="external">箭头函数</a>,<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">解构</a>和<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/template_strings" target="_blank" rel="external">模板字符串</a></li>
<li>Mac OS X 终端 （好吧，你应该有个Mac或者Macbook）</li>
<li>CSS：flexbox (<a href="http://flexboxfroggy.com/" target="_blank" rel="external">这里</a>有个非常棒的flexbox游戏教程)</li>
<li><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a>：React的一些基本概念需要知道，比如<code>JSX</code>、<code>state</code>和<code>prop</code>的区别、<code>Virtual DOM</code>。</li>
</ul>
<h1 id="再谈谈文章的规划"><a href="#再谈谈文章的规划" class="headerlink" title="再谈谈文章的规划"></a>再谈谈文章的规划</h1><p>由于涉及的知识点较多，<code>构建我的第一个iOS app</code>将分为两篇来完成。每一篇有<strong>五个章节</strong>，每个章节会推进一步，直至完成预期。文章略长，一旦开始，最好以章节为单位来进行。建议先收藏，回家坐在电脑前慢慢品。</p>
<h1 id="1-First-Blood-建一个空React-Native项目"><a href="#1-First-Blood-建一个空React-Native项目" class="headerlink" title="1. First Blood:建一个空React Native项目"></a>1. First Blood:建一个空React Native项目</h1><p>首先确认已安装：</p>
<ul>
<li><a href="https://developer.apple.com/xcode/" target="_blank" rel="external">XCode 7.0或更高版本</a></li>
<li><a href="https://nodejs.org/en/" target="_blank" rel="external">Node</a></li>
</ul>
<p>然后，在终端输入：<code>npm install -g react-native-cli</code>，全局安装React Native。</p>
<p>如果你觉得我说的不够详细，请移步<a href="https://facebook.github.io/react-native/docs/getting-started.html#content" target="_blank" rel="external">React Native的官方安装文档</a></p>
<p>在你电脑找块风水宝地，用于初始化项目目录。在该文件夹下执行命令：<code>react-native init PIW</code>。<br><img src="init.png" alt="init"><br>（<code>PIW</code>是<code>Pick Image as Wallpaper</code>的缩写，不要在意这个细节，我为了装X起的。另，鉴于网络因素，等待时间应该较长，此时可以去小个便，或者逗逗你的宠物。）</p>
<p><code>init</code>后的项目目录：</p>
<p><img src="dir.png" alt="项目目录"></p>
<p>很显然，<code>index.android.js</code>和<code>index.ios.js</code>分别是安卓和苹果应用的入口执行文件，由于我们构建的是iOS APP，所以接下来只跟<code>index.ios.js</code>打交道。接下来，移步<code>ios</code>文件夹，并双击打开<code>PIW.xcodeproj</code>。（Xcode的工程文件）<br><img src="xcode.png" alt="第一眼看到的xcode项目页面"><br>注意有个警告：<code>No matching provisioning profiles found.</code>。得想办法修复它。先改个名字，<strong>Bundle Identifier</strong>：<code>com.zerosoul.me.tutorial.PIW</code>怎么样？有木有感觉很高大上！只要遵循<a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation" target="_blank" rel="external">Reverse DNS Convention</a>，请随意。然后选择<strong>Team</strong>，没有则按照指示新建一个。最后，点击<strong>Fix Issue</strong>。</p>
<p><strong>Deployment Info</strong>一栏需要改动些默认设置，让app不能横屏，并且隐藏顶部的状态栏，下图红框已标出：<br><img src="deployinfo.png" alt="deployment info"></p>
<p>好了，可以点击左上角的<strong>Run</strong>，看一看模拟器的效果了。中途应该会蹦出一个终端弹窗，不要慌，正常现象。<br><img src="popup.png" alt="terminal popup"></p>
<p>一旦Xcode构建完，在模拟器里你会看到这一幕：<br><img src="welcome.jpg" alt="welcome to React Native"></p>
<p><strong>注：此处有坑，如果你用真机模拟，会出现这么一幕：</strong><br><img src="localhost.png" alt="大红的懵逼"><br>大红的懵逼！不过别慌，官方文档有对应的解决方法，移步<a href="https://facebook.github.io/react-native/docs/running-on-device-ios.html" target="_blank" rel="external">这里</a>可以找到解决方式。</p>
<h1 id="2-从第三方获取壁纸数据"><a href="#2-从第三方获取壁纸数据" class="headerlink" title="2. 从第三方获取壁纸数据"></a>2. 从第三方获取壁纸数据</h1><p>既然要做壁纸APP，大量适合做手机壁纸的图片从哪里来？还记得前面提到的Unsplash吗？一切的遇见都不是偶然，好心的歪果仁做了一个<a href="https://unsplash.it/" target="_blank" rel="external">Unsplash图片调用接口</a>，用于生成一些精美占位图，非常方便！</p>
<h2 id="有关ES6中“类”的解释"><a href="#有关ES6中“类”的解释" class="headerlink" title="有关ES6中“类”的解释"></a>有关<code>ES6</code>中“类”的解释</h2><p>你可能会注意到，有些React代码会出现<code>var PIW = React.createClass({ ... })</code>，有些会是<code>class PIW extends Component{ ... }</code>。呵呵，这是个历史遗留问题，用哪种风格是个人选择问题，不存在孰优孰劣，有选择恐惧症的同学可以看看<a href="https://reactjsnews.com/composing-components" target="_blank" rel="external">这篇文章</a>。</p>
<p>此处，我选择<code>Recat.Component</code>风格，别问我为什么，就这么任性！<br><img src="renxing.jpg" alt="任性"></p>
<h2 id="开始做一些改动"><a href="#开始做一些改动" class="headerlink" title="开始做一些改动"></a>开始做一些改动</h2><p>在<code>PIW</code>类里面，第一件事情便是加个构造函数<code>constructor</code>，在此初始化两个State：<code>wallsJSON</code>和<code>isLoading</code>。<code>wallsJSON</code>用于存储从第三方接口获取的json数组数据，<code>isLoading</code>是个布尔变量，用于标识数据是否加载完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class PIW extends Component&#123;</div><div class="line">/***/</div><div class="line">  constructor(props) &#123;</div><div class="line">    super(props);</div><div class="line">    this.state = &#123;</div><div class="line">      wallsJSON: [],</div><div class="line">      isLoading: true</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">/***/</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注：方便起见，涉及的代码改动，我用`/*</strong>/<code>隔离标识出，下同。**
既然有存放数据的变量了，就得有给之赋值的函数，好吧，在</code>constructor<code>下面加一个占位函数</code>fetchWallsJSON`:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fetchWallsJSON() &#123;</div><div class="line">    console.log(‘壁纸数据从这里加载...’);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从业务逻辑来讲，组件一旦加载完毕，就应该触发该函数。那么，该<code>componentDidMount</code>上场了，它是React Native组件的生命周期函数之一，在首次渲染（<code>render</code>）成功后会触发。想要更系统地理解组件的生命周期，请移步<a href="https://facebook.github.io/react/docs/component-specs.html" target="_blank" rel="external">这里</a>。注意，既然我们用的ES6的类语法，就可以省略<code>getInitialState</code>了，取而代之的是在<code>constructor</code>中给<code>this.state</code>赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    this.fetchWallsJSON();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>fetchWallsJSON</code>里会打印信息，我们应该从哪儿看到呢？首先，让模拟器获取焦点，使用<code>CMD + D</code>组合键调出调试菜单，选择<strong>Debug in Chrome</strong>，好吧，顺便把<strong>Enable live reload</strong>也打开吧，妈妈再也不用担心每次都要手动重启APP了。将会在Chrome里打开一个新标签，按照上面的说明调出<strong>console</strong>的界面。啊哈！<br><img src="console.png" alt="console data loaded tip"><br>坑占好了，下面，可以开始考虑引入真实数据了。访问URL：<a href="http://unsplash.it/list" target="_blank" rel="external">unsplash.it/list </a>，你将会看到铺满全屏的数据，接下来我们就基于这些数据做文章啦~~~<br>首先，替换掉<code>console</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fetchWallsJSON() &#123;</div><div class="line">    /***/</div><div class="line">    var url = &apos;http://unsplash.it/list&apos;;</div><div class="line">    fetch(url)</div><div class="line">      .then( response =&gt; response.json() )</div><div class="line">      .then( jsonData =&gt; &#123;</div><div class="line">        console.log(jsonData);</div><div class="line">      &#125;)</div><div class="line">    .catch( error =&gt; console.log(‘获取数据有误： ‘ + error) );</div><div class="line">    /***/</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><strong>注：用到了<code>fetch</code>函数，不熟悉的同学请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="external">这里</a></strong><br>保存然后刷新，几秒过后，啊哈！<br><img src="consolerealdata.png" alt="console real data"></p>
<p>太好了，我们已经能从第三方拿到数据了！在打印出数据前会有点延迟，这很正常，因为从请求到响应回数据会有个等待时间，此处应有<strong>加载提示</strong>。</p>
<h1 id="3-增加加载提示"><a href="#3-增加加载提示" class="headerlink" title="3. 增加加载提示"></a>3. 增加加载提示</h1><p>首先，把<code>PIW</code>类里<code>render</code>代码全部删除，新增以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    var &#123;isLoading&#125; = this.state;</div><div class="line">    if(isLoading)</div><div class="line">      return this.renderLoadingScreen();</div><div class="line">    else</div><div class="line">      return this.renderResults();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>里面新增了两个函数，我们来实现它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">renderLoadingScreen() &#123;</div><div class="line">    return (</div><div class="line">        &lt;View style=&#123;styles.loadingContainer&#125;&gt;</div><div class="line">            &lt;ActivityIndicatorIOS</div><div class="line">              animating=&#123;true&#125;</div><div class="line">              color=&#123;&apos;#fff&apos;&#125;</div><div class="line">              size=&#123;&apos;small&apos;&#125; </div><div class="line">              style=&#123;&#123;margin: 15&#125;&#125; /&gt;</div><div class="line">              &lt;Text style=&#123;&#123;color: &apos;#fff&apos;&#125;&#125;&gt;正在加载数据...&lt;/Text&gt;</div><div class="line">           </div><div class="line">       &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  renderResults() &#123;</div><div class="line">    return (</div><div class="line">        &lt;View&gt;</div><div class="line">            &lt;Text&gt;</div><div class="line">             数据已加载</div><div class="line">            &lt;/Text&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>根据<code>isLoading</code>的不同状态，渲染不同的界面。但是请注意，我们好像忘了什么。啊哈，<code>isLoading</code>并没有改变状态，应该在哪儿将其状态变过来呢？<code>fetchWallsJSON</code>！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">fetch(url)</div><div class="line">  .then( response =&gt; response.json() )</div><div class="line">  .then( jsonData =&gt; &#123;</div><div class="line">    console.log(jsonData);</div><div class="line">/***/</div><div class="line">    this.setState(&#123;isLoading: false&#125;); //更新 isLoading </div><div class="line">/***/</div><div class="line">  &#125;)</div><div class="line">.catch( error =&gt; console.log(‘获取数据有误：‘ + error) );</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>有关<code>setState</code>的详细说明请移步<a href="https://facebook.github.io/react/docs/component-api.html" target="_blank" rel="external">这里</a>，一句话描述其作用就是用于触发UI更新。<br>另外，我们在<code>renderLoadingScreen</code>调用了一个新组件<code>ActivityIndicatorIOS</code>，因此，需要在头部引入之：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import &#123;</div><div class="line">  AppRegistry,</div><div class="line">  StyleSheet,</div><div class="line">  Text,</div><div class="line">  View,</div><div class="line">  /***/</div><div class="line">  ActivityIndicatorIOS // 增加新组件</div><div class="line">  /***/</div><div class="line">&#125; from &apos;react-native&apos;;</div></pre></td></tr></table></figure></p>
<p>在看到最终效果前，还有一件事情：注意到<code>&lt;View&gt;</code>标签内有个<code>styles.loadingContainer</code>没有？没错，这是用来定义<code>View</code>的样式的，目前可以这样理解：React内的样式全部用行内样式来定义的。而样式则通过<code>var styles = StyleSheet.create({…</code>来创建，只需要在相应的组件里加以引用即可：<br>创建<code>loadingContainer</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var styles = StyleSheet.create(&#123;</div><div class="line">/***/</div><div class="line">  loadingContainer: &#123;</div><div class="line">    flex: 1,</div><div class="line">    flexDirection: &apos;row&apos;,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#000&apos;</div><div class="line">  &#125;</div><div class="line">/***/</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>引用<code>loadingContainer</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;styles.loadingContainer&#125;/&gt;</div></pre></td></tr></table></figure></p>
<p>当然，也可以这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;&#123;</div><div class="line">    flex: 1,</div><div class="line">    flexDirection: &apos;row&apos;,</div><div class="line">    justifyContent: &apos;center&apos;,</div><div class="line">    alignItems: &apos;center&apos;,</div><div class="line">    backgroundColor: &apos;#000&apos;</div><div class="line">  &#125;&#125; /&gt;</div></pre></td></tr></table></figure></p>
<p>不过这样做代码的可读性和可维护性较差，尤其在有很多组件的时候，容易乱套，所以并不是一个好的实践。另外，注意到没，React Native严重依赖<code>flexbox</code>布局元素，所以，学好<code>flexbox</code>这个知识点就很有必要。</p>
<p>保存这些改动，你将会在模拟器中看到以下加载页面：<br><img src="loading.png" alt="loading screen"><br>过个几秒钟，将会转为：<br><img src="loaded.png" alt="data loaded"></p>
<h1 id="4-筛选出随机的壁纸"><a href="#4-筛选出随机的壁纸" class="headerlink" title="4. 筛选出随机的壁纸"></a>4. 筛选出随机的壁纸</h1><p>这一章节侧重于Javascript的编码，将创建一个专门的模块用于生成随机数。如果模块的概念感到陌生，请先移步<a href="https://nodejs.org/api/modules.html#modules_modules" target="_blank" rel="external">Node.js的模块文档</a>。</p>
<p>首先，我们在<code>index.ios.js</code>的<code>class</code>声明前定义一个常量，用于决定要随机选取的壁纸数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const NUM_WALLPAPERS = 5;</div></pre></td></tr></table></figure></p>
<p>然后创建一个用户生成随机数的模块，这个模块内有两个函数：</p>
<ul>
<li><code>uniqueRandomNumbers</code>：该函数有三个参数，第一个决定了将要返回的随机数数量，后面两个定义随机数选取的范围。比如调用<code>uniqueRandomNumbers(5,10,20)</code>将获得包含5个随机数的数组，他们的范围在10到20之间。</li>
<li><code>randomNumberInRange</code>：该函数有两个参数，定义了随机数范围，并返回一个随机数。比如调用<code>randomNumberInRange(2,10)</code>将返回介于2到10的随机的一个数。</li>
</ul>
<p>当然，我们完全可以将这两个函数合并为一个，但遵循<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="external"><strong>单一职责原则</strong></a>应该是编码的最佳实践：一个函数只做一件事并将其做好。相信我，遵循好的编程原则能让以后的日子好过一些。</p>
<p>好了，思路表述完了，开始编码。首先，在根目录下新建一个js文件<code>RandManager.js</code>，以下是代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    uniqueRandomNumbers(numRandomNumbers, lowerLimit, upperLimit) &#123;</div><div class="line">        var uniqueNumbers = [];</div><div class="line">        while( uniqueNumbers.length != numRandomNumbers ) &#123;</div><div class="line">            var currentRandomNumber = this.randomNumberInRange(lowerLimit, upperLimit);</div><div class="line">            if( uniqueNumbers.indexOf(currentRandomNumber) === -1 ) </div><div class="line">                uniqueNumbers.push(currentRandomNumber);</div><div class="line">        &#125;</div><div class="line">        return uniqueNumbers;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    randomNumberInRange(lowerLimit, upperLimit) &#123;</div><div class="line">        return Math.floor( Math.random() * (1 + upperLimit - lowerLimit) ) + lowerLimit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在<code>index.ios.js</code>中引用<code>RandManager</code>模块：<code>var RandManager = require(&#39;./RandManager.js&#39;);</code>，然后我们就可以在<code>fetchWallsJSON</code>中调用啦：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">fetchWallsJSON() &#123;</div><div class="line">  var url = &apos;http://unsplash.it/list&apos;;</div><div class="line">  fetch(url)</div><div class="line">    .then( response =&gt; response.json() )</div><div class="line">    .then( jsonData =&gt; &#123;</div><div class="line">    /***/</div><div class="line">      var randomIds = RandManager.uniqueRandomNumbers(NUM_WALLPAPERS, 0, jsonData.length);</div><div class="line">      var walls = [];</div><div class="line">      randomIds.forEach(randomId =&gt; &#123;</div><div class="line">        walls.push(jsonData[randomId]);</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      this.setState(&#123;</div><div class="line">        isLoading: false,</div><div class="line">        wallsJSON: [].concat(walls)</div><div class="line">      &#125;);</div><div class="line">    /***/</div><div class="line">    &#125;)</div><div class="line">    .catch( error =&gt; console.log(&apos;获取数据有误：&apos; + error) );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码应该不用过多解释了，使用<code>uniqueRandomNumbers</code>生成5个随机数作为<code>jsonData</code>的索引值，进而获取5个随机壁纸数据并存入<code>wallsJSON</code>，哦对了，别忘了更新<code>isLoading</code>。</p>
<p>有了随机数据，就可以在<code>renderResults</code>里使用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">renderResults() &#123;</div><div class="line">/***/</div><div class="line">   //这里用到了ES6中的解构</div><div class="line">  var &#123;wallsJSON, isLoading&#125; = this.state;</div><div class="line">  if( !isLoading ) &#123;</div><div class="line">    return (</div><div class="line">      </div><div class="line">    &lt;View&gt;</div><div class="line">        &#123;wallsJSON.map((wallpaper, index) =&gt; &#123;</div><div class="line">          return(</div><div class="line">            &lt;Text key=&#123;index&#125;&gt;</div><div class="line">              &#123;wallpaper.id&#125;</div><div class="line">            &lt;/Text&gt;</div><div class="line">          );</div><div class="line">        &#125;)&#125;</div><div class="line">       </div><div class="line">    &lt;/View&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">/***/</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码有个地方值得注意：React Native通过循环数组或集合渲染子元素时，需要给每个元素制定一个唯一的<code>key</code>，这也是为啥<code>&lt;Text key={index}&gt;</code>这样写的原因。</p>
<p>保存代码，模拟器刷新后，我们看到了五个不同的id：<br><img src="randid.png" alt="random id"><br>当然，可以将<code>id</code>改为<code>author</code>，这样，我们看到的是五个不同的名字：<br><img src="randname.png" alt="random name"></p>
<p>非常好，我们现在已经可以自如地操控数据了。</p>
<h1 id="5-新增Swiper组件"><a href="#5-新增Swiper组件" class="headerlink" title="5. 新增Swiper组件"></a>5. 新增Swiper组件</h1><p>React Native有强大的社区支持和<a href="https://react.parts/native" target="_blank" rel="external">丰富的组件库</a>。这一章节学习如何引入第三方组件。<br>对于我们当前的APP，需要一个可滑动浏览图片的组件，推荐<a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="external">react-native-swiper</a>。</p>
<p>终端切换到项目根目录，运行命令：<code>npm install react-native-swiper --save</code>，然后<code>require</code>到代码里：<code>var Swiper=require(&#39;react-native-swiper&#39;)</code>。<br>将<code>renderResults</code>里的<code>View</code>替换为<code>Swiper</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">renderResults() &#123;</div><div class="line">  var &#123;wallsJSON, isLoading&#125; = this.state;</div><div class="line">  if( !isLoading ) &#123;</div><div class="line">    return (</div><div class="line">    /***/</div><div class="line">      &lt;Swiper&gt;</div><div class="line">    /***/</div><div class="line">        &#123;wallsJSON.map((wallpaper, index) =&gt; &#123;</div><div class="line">          return(</div><div class="line">            &lt;Text key=&#123;index&#125;&gt;</div><div class="line">              &#123;wallpaper.author&#125;</div><div class="line">            &lt;/Text&gt;</div><div class="line">          );</div><div class="line">        &#125;)&#125;</div><div class="line">    /***/</div><div class="line">      &lt;/Swiper&gt;</div><div class="line">    /***/</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不出意外的话，界面将变成下面这样：<br><img src="swiperwithdata.png" alt="swiper with name data"><br>下面，根据<a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="external">Swiper组件的文档</a>，我们来微调一下样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;Swiper</div><div class="line">/***/</div><div class="line">dot=&#123;&lt;View style=&#123;&#123;backgroundColor:&apos;rgba(255,255,255,.4)&apos;, width: 8, height: 8,borderRadius: 10, marginLeft: 3, marginRight: 3, marginTop: 3, marginBottom: 3,&#125;&#125; /&gt;&#125;</div><div class="line">activeDot=&#123;&lt;View style=&#123;&#123;backgroundColor: &apos;#fff&apos;, width: 13, height: 13, borderRadius: 7, marginLeft: 7, marginRight: 7&#125;&#125; /&gt;&#125;</div><div class="line">loop=&#123;false&#125;</div><div class="line">onMomentumScrollEnd=&#123;this.onMomentumScrollEnd&#125;</div><div class="line">/***/</div><div class="line">&gt;</div><div class="line">  &#123;wallsJSON.map((wallpaper, index) =&gt; &#123;</div><div class="line">    return(</div><div class="line">      &lt;Text key=&#123;index&#125;&gt;</div><div class="line">        &#123;wallpaper.author&#125;</div><div class="line">      &lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;)&#125;</div><div class="line">&lt;/Swiper&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li>微调了下底部分页小圆点，更大更黑了（卧槽，我在说什么…）</li>
<li>禁用了循环，这样，一旦浏览到最后一页，然后就没有然后了。</li>
<li>新增了每一页滑动完毕后的触发事件：<code>onMomentumScrollEnd</code>（这个会在下一篇文章中用到，此处先占个坑）</li>
</ul>
<p>我们已经把Swiper加上了，好啦，这一节就写到这里，因为…我累了。<br><img src="shuaiqi.jpg" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写到这里，我发现文章已经挺长的了。那么…再加个总结吧，都这么长了，应该不介意再长一点吧。<br><img src="youdaoli.jpg" alt="有道理"></p>
<ul>
<li>第一节讲的是如何新建一个空的React Native项目</li>
<li>第二节讲的是如何从第三方API获取原始数据，并建议用ES6新语法来构建程序</li>
<li>第三节我们根据APP不同的状态渲染出不同的界面</li>
<li>第四节我们新建了一个模块，引入并解决了产生随机数的问题</li>
<li>第五节我们新增了一个第三方组件，并做了简单设置。</li>
</ul>
<p>好吧，必须承认，目前为止，我们的APP看起来似乎没啥特殊之处。不过，刚入门嘛，一步一步走到这里，也不容易了。下一篇文章，我们将继续打磨这个APP，新增特性预告：</p>
<ul>
<li>作者名字将替换为图片，没错，高清无码大图</li>
<li>自定义双击事件，保存图片到相册：<code>PanHandler</code></li>
<li>通过Xcode新增类库并获取相应授权，比如访问相册</li>
<li>增加预览功能</li>
<li>创建更多的自定义组件<br>哦对了，最终代码在<a href="https://github.com/zerosoul/PIW" target="_blank" rel="external">这儿</a>。年轻人，我们下一回合见…<br><img src="dengyan.png" alt=""></li>
</ul>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.smashingmagazine.com/2016/04/the-beauty-of-react-native-building-your-first-ios-app-with-javascript-part-1/" target="_blank" rel="external">The Beauty Of React Native: Building Your First iOS App With JavaScript (Part 1)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;rn.png&quot; alt=&quot;React Native&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h1&gt;&lt;p&gt;严格来说这是一篇译
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="react" scheme="http://zerosoul.github.io/tags/react/"/>
    
      <category term="ReactNative" scheme="http://zerosoul.github.io/tags/ReactNative/"/>
    
      <category term="app" scheme="http://zerosoul.github.io/tags/app/"/>
    
      <category term="翻译" scheme="http://zerosoul.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>探索 Javascript Promise</title>
    <link href="http://zerosoul.github.io/2016/05/26/everything-about-promise/"/>
    <id>http://zerosoul.github.io/2016/05/26/everything-about-promise/</id>
    <published>2016-05-26T13:29:34.000Z</published>
    <updated>2016-05-27T02:03:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="promise.jpg" alt="javascript promise"></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>先看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="comment">// do something with the result</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果有似曾相识的感觉，那么你在理解javascript中的promise道路上已经迈出了一步。如果完全懵逼，别怕，接下来我们通过例子来了解promise为何物。</p>
<p>作为新概念，一些人理解promise起来会有些困难，因为这需要思维上的转变。但是请相信我，经过几个实例的讲解，你会发现它的优雅：它使得让人头痛的异步代码写起来更为轻松，而且可以避免“回调大坑”（<a href="http://callbackhell.com/" target="_blank" rel="external">callback hell</a>）。</p>
<p>promise背后的思想是：</p>
<blockquote>
<p>promise代表的是异步操作的<strong>最终</strong>（eventual）结果</p>
</blockquote>
<p>这意味着异步操作的结果并不能立即获取，而是要等到promise稳定了（settled）。</p>
<p>想想你在日常生活中做出承诺（promise）的例子：小时候，你出门对老妈说：我保证（promise）把垃圾带出去。这句话的意思是在稍后的某个时间点你会去做<strong>扔垃圾</strong>这件事并兑现你的承诺。也许几分钟，也许几小时，也许…</p>
<p>promise亦是如此。当一个函数返回一个promise，它其实是在说：嘿！我向你承诺，一旦完事，我将带着结果去找你！</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>好啦，理论和术语的东西讲多了让人烦，下面我们来例证上面说的一堆话。</p>
<p>AJAX的概念应该不陌生吧，相信你之前使用过原生<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">XMLHttpRequest</a>，或者jQuery的<a href="http://api.jquery.com/jquery.ajax/" target="_blank" rel="external">$.ajax()</a>，或者其它类库。不过，XMLHttpRequest API既复杂又难记忆。谢天谢地，新API <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API" target="_blank" rel="external">fetch</a>简化了ajax的应用，并且，它用到了promise！</p>
<p>这意味着什么？其实，每当你使用fetch()发出请求，像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/some/endpoint'</span>)</div></pre></td></tr></table></figure></p>
<p>它就会返回一个promise对象。</p>
<p>通常我们会使用回调函数来响应异步请求完成时的操作。但是，在promise的世界里，我们得使用<code>then()</code>来达到这一目的。</p>
<p>通过链式调用<code>.then(onFulfilled, onRejected)</code>来访问<code>fetch</code>的结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/some/endpoint'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Response from the endpoint '</span> + result)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'An error occurred: '</span> + error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>then</code>方法提供两个参数：</p>
<ol>
<li><code>onFulfilled</code>：当promise完成（fulfilled）时调用，第一个参数表示promise的结果。</li>
<li><code>onRejected</code>：当promise被拒（rejected）时调用，第一个参数表示promise被拒的原因。</li>
</ol>
<p><strong>完成</strong>和<strong>被拒</strong>是promise的两个状态，其实还有第三种状态：挂起（pending）。现在，我们来总结下<code>fetch</code>使用promise的经过：</p>
<ol>
<li>从调用<code>fetch()</code>那一刻，它就返回了一个promise对象</li>
<li>在请求完成之前，promise的状态一直处于<strong>挂起</strong></li>
<li>promise由挂起状态，可能会转为<strong>完成</strong>，也可能会是<strong>被拒</strong>。</li>
</ol>
<p>值得一提的是，一旦promise的状态转为完成或被拒，其值将不再改变。</p>
<h1 id="使用catch-错误处理"><a href="#使用catch-错误处理" class="headerlink" title="使用catch()错误处理"></a>使用<code>catch()</code>错误处理</h1><p><a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+ 规范 </a>提供了一种语法糖来处理promise的错误。</p>
<p>假设有个<code>lookupPrice(itemId)</code>函数，功能是查找数据库中特定商品的价格，如果存在记录则表示成功，否则表示失败。无论如何，最终返回一个promise对象，我们可以使用<code>catch()</code>来使代码更具可读性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lookupPrice(<span class="number">123</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'The item costs: '</span> + price)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Could not find an item with that ID'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>如果商品存在，将会打印：<code>The item costs: 50</code>，如果不存在，则打印：<code>Could not find an item with that ID</code>。</p>
<p>如果你对<code>then()</code>情有独钟，上面的那段代码可以改写成下面的链式调用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">lookupPrice(<span class="number">123</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'The item costs: '</span> + price)</div><div class="line">  &#125;, <span class="literal">null</span>)</div><div class="line">  .then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Could not find an item with that ID'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>如果一个promise被拒，代码将直接跳到第一个<code>catch</code>或者有<code>onRejected</code>的<code>then</code>链式调用处。</p>
</blockquote>
<p>比如当我们使用一个不存在的商品id来调用<code>lookupPrice()</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">lookupPrice(<span class="number">99999</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'The item costs: '</span> + price)</div><div class="line">    <span class="keyword">return</span> price</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Double the price: '</span> + (price * <span class="number">2</span>))</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Could not find an item with that ID'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>由于两个<code>then</code>都没有<code>onRejected</code>，均被忽略了，代码直接跳到<code>catch</code>执行。</p>
<p>接下来再列举两个代码片段，它们有细微差别，您瞧好了：<br>片段1：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 then(onFulfilled, onRejected)</span></div><div class="line">lookupPrice(<span class="number">123</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="comment">// lookup another price and return the promise created by lookupPrice(456)</span></div><div class="line">    <span class="keyword">return</span> lookupPrice(<span class="number">456</span>)</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Item 123 does not exist'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>片段2：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 catch()</span></div><div class="line">lookupPrice(<span class="number">123</span>)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</div><div class="line">    <span class="comment">// lookup another price and return the promise created by lookupPrice(456)</span></div><div class="line">    <span class="keyword">return</span> lookupPrice(<span class="number">456</span>)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Either item 123 OR 456 does not exist'</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure></p>
<p>片段1中，如果商品123不存在，带有<code>onRejected</code>的<code>then</code>将会被立即执行：</p>
<ul>
<li>在这个例子中将会打印“Item 123 does not exist”</li>
<li>然而，并没有给<code>lookupPrice(456)</code>指定错误处理函数，所以，如果商品456不存在，什么都不会打印。这是个未捕捉到的错误(Uncaught error)。</li>
</ul>
<p>需要提醒的一点：当你链式调用<code>then(onFulfilled, onRejected)</code>，被执行的或者是<code>onFulfilled</code>，或者是<code>onRejected</code>，绝对不是两个都执行。</p>
<p>片段2中：</p>
<ul>
<li>如果商品123不存在，代码直接进入<code>catch</code>，打印“Either item 123 OR 456 does not exist”</li>
<li>由于在<code>then</code>之后链式调用了<code>catch</code>，在此之前任何promise转到了被拒状态，都将进入<code>catch</code>。所以，如果商品456也不存在，也会在屏幕上看到“Either item 123 OR 456 does not exist”。</li>
</ul>
<h1 id="使用new-Promise-创建promise"><a href="#使用new-Promise-创建promise" class="headerlink" title="使用new Promise()创建promise"></a>使用<code>new Promise()</code>创建promise</h1><p>目前为止，我们通过<code>fetch</code>API来了解了promise，通过<code>then</code>来使用promise的结果。多数情况下，我们会用到各式各样的类库来使用promise。然而，有时还是需要自己创建promise，自主决定什么情况下转入完成，什么情况下转入被拒。</p>
<p>使用构造函数<code>Promise(resolver)</code>来创建promise实例，其中<code>resolver</code>接收两个参数：resolve和reject。似曾相识？恩哼？！</p>
<p>举个栗子：比如我们想创建一个随机数1到10生成函数，并且返回一个promise。如果数字小于5，进入<code>resolve</code>（意味着操作成功），如果大于5，进入<code>reject</code>（意味着操作失败）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomNumber</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> randomNumber = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> (randomNumber &lt;= <span class="number">5</span>) &#123;</div><div class="line">      resolve(randomNumber)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      reject(randomNumber)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">generateRandomNumber().then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Success: '</span> + result)</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="链式调用：一次只完成一个任务"><a href="#链式调用：一次只完成一个任务" class="headerlink" title="链式调用：一次只完成一个任务"></a>链式调用：一次只完成一个任务</h1><p>链式调用多个<code>then</code>，可以做到进一步处理返回值，并且顺序化执行其它异步任务。</p>
<p>在一些业务场景，这非常有用。比如，你要调用某个终端来认证用户，一旦认证成功，我们调用另一个终端来获取用户资料。</p>
<p>上面那个场景用代码来表示的话，类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 认证id为333的用户</span></div><div class="line">fetch(<span class="string">'/auth/333'</span>)</div><div class="line">   <span class="comment">//将响应对象传值给authStatus，用以确认认证成功与否</span></div><div class="line">  .then(authStatus)</div><div class="line">  <span class="comment">//认证成功了，则继续调用loadProfile，并传入用户名</span></div><div class="line">  .then(loadProfile)</div><div class="line">  <span class="comment">//认证失败了，进入catch处理程序</span></div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authStatus</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</div><div class="line">    <span class="comment">//用户名将传入下一个`then`，即loadProfile</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response.userName)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 认证失败，进入reject</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'User cannot be authenticated'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadProfile</span> (<span class="params">userName</span>) </span>&#123;</div><div class="line">  fetch(<span class="string">'/profile/'</span> + userName)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(response.profileData)</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议花上一两分钟看上几遍上面代码，研究下各个部分是如何组合在一起的。</p>
<p>有两个地方需要特别注意下：</p>
<ul>
<li>一旦promise转为<strong>完成</strong>状态，它的值将被当做参数自动传入下一个<code>then</code>方法中。</li>
<li>如果认证失败，将立即进入<code>catch</code>，并略过<code>.then(loadProfile)</code>。</li>
</ul>
<h1 id="Promise-all-：一次搞定！"><a href="#Promise-all-：一次搞定！" class="headerlink" title="Promise.all()：一次搞定！"></a>Promise.all()：一次搞定！</h1><p>如果我们不关心异步操作的执行顺序，换句话说，假如我们想在获取用户信息的同时，把最近发表的文章也获取了，该怎么办？</p>
<p>这时候就该<code>Promise.all()</code>上场了。它将promise数组作为参数传入，并且实例化一个promise，只有当数组中所有的promise都转为完成状态时，该实例化promise才进入完成状态。但是，请记住，一旦参数中有一个promise是被拒状态，Promise.all()也就进入了被拒状态。要么所有的promise都完成，要么全部被拒。</p>
<p>Promise.all()完成返回的结果是一个数组，其中的值对应参数中的promise数组。下面根据刚刚提到的那个场景，我们使用Promise.all()来实现下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  fetch(<span class="string">'/profile/333'</span>), <span class="comment">// 获取用户信息</span></div><div class="line">  fetch(<span class="string">'/posts/user/333'</span>) <span class="comment">// 获取用户文章</span></div><div class="line">])</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</div><div class="line">  <span class="comment">// `result`是一个长度为2的数组</span></div><div class="line">  <span class="keyword">var</span> profileInfo = result[<span class="number">0</span>].profileData</div><div class="line">  <span class="keyword">var</span> recentPosts = result[<span class="number">1</span>].posts</div><div class="line"></div><div class="line">  <span class="comment">//处理数据 BLA BLA ~~~</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h1 id="就这些了！我保证！（I-Promise）"><a href="#就这些了！我保证！（I-Promise）" class="headerlink" title="就这些了！我保证！（I Promise）"></a>就这些了！我保证！（I Promise）</h1><p>一旦开始在代码中实践Promise，你会发现一切都变得相当简单。因此我建议你打开Chrome/Firefox的开发者工具，走一遍这篇文章里的例子。</p>
<p>需要指出的是，有一个Promise的API我还没有提及:<code>Promise.race()</code>。它和<code>Promise.all()</code>类似，传入一个promise数组，并实例化一个promise，但不同之处在于传入的promise有任何一个转为完成，实例化的promise便进入完成，任何一个promise转为被拒，便进入被拒。个人认为，这并不十分实用，但我认为有一些特定业务场景会用得上它，你可以在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="external">这儿</a>熟悉下这个API，祝好运！</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://coligo.io/javascript-promises-plain-simple/" target="_blank" rel="external">JavaScript Promises: Plain and Simple</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">MDN:Promise</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;promise.jpg&quot; alt=&quot;javascript promise&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;先看一段代码：&lt;br&gt;&lt;fi
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="译文" scheme="http://zerosoul.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="技术" scheme="http://zerosoul.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javascript" scheme="http://zerosoul.github.io/tags/javascript/"/>
    
      <category term="promise" scheme="http://zerosoul.github.io/tags/promise/"/>
    
      <category term="ES6" scheme="http://zerosoul.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>读《从0到1》</title>
    <link href="http://zerosoul.github.io/2016/05/22/zero-to-one/"/>
    <id>http://zerosoul.github.io/2016/05/22/zero-to-one/</id>
    <published>2016-05-22T09:17:59.000Z</published>
    <updated>2016-05-22T11:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="paypal_team.jpg" alt="paypal team"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的生活里充满了套路：</p>
<ul>
<li>凌晨四点总会醒来，然后撒泡尿继续睡觉；</li>
<li>每天早上必须洗澡，不然一天浑身难受；</li>
<li>出门经常性不锁门，只是随手一带；</li>
<li>自行车从来不上锁，即使是放在了地铁口；</li>
<li>随身现金从来没超过200，能支付宝就微信；</li>
<li>跑完步一定要发朋友圈，不然就觉得白跑了；</li>
</ul>
<p>读书也是，一般会避开畅销书，挑选豆瓣评分较高的经典书，也会从一本书开始了解到作者，进而选读他的其他作品，还会无意间听到一个牛人，知道他写过某本书，然后买来开始拜读。好吧，绕了一大圈子，终于开始进入主题了，今天要记录的就是我读书套路的最后一种：彼得蒂尔写的《从0到1》。</p>
<p>这是本畅销书，和其他大多数畅销书类似，没有提出任何新知，一直在强调的是在我们中学课本上就在强调的创新，新瓶装旧酒，<strong>有用的废话</strong>大集合。但是仍然值得一读，因为它确实有料。我们可以先从说一说彼得蒂尔开始…</p>
<h1 id="其人其事"><a href="#其人其事" class="headerlink" title="其人其事"></a>其人其事</h1><p>彼得蒂尔毕业于斯坦福法学院，1996年成立Thiel Capital，2002年改名为Clarium Capital，公司拥有的资产达55亿美元。他于1998年与他人共同创立了PayPal，2002年以15亿美元的价格售出，个人获利6千万美元。他还是Facebook的首个外部投资者。他打造了多家异军突起的公司，《从0到1》展现了他到底是如何做到的。所以，当一个有冒险精神的人写书了，务必要读一读。</p>
<p>尼采曾在精神错乱前写道：“个人发生精神错乱很少见，但对群体、政党、国家、时代而言，精神错乱很普遍。”如果你能识别出那些不切实际你的大众观点，你就能看到隐藏在这些观点背后的反主流事实。《从0到1》就是能让我们识别出“反主流事实”的一本书。</p>
<h1 id="其书珠玑"><a href="#其书珠玑" class="headerlink" title="其书珠玑"></a>其书珠玑</h1><p>从零到一，或者说从无到有，意味着企业要善于创造和创新，通过技术专利、网络效应、规模经济、品牌等形成壁垒，从而实现质的垂直性层级跨越，由此开辟一个只属于自己的蓝海市场而成为这个市场的唯一，这样的垄断足可以让企业安享丰厚利润。</p>
<p>当代企业的经营境界有三层：企业只是制造满足市场需求的产品，只要有原型，工业流水线可以让产品大量复制生产出来，是为第一层；企业创造了良好的基因组织，因而可以与时俱进地不断进化，实现纵向的传承，其最好的产品便是企业自身，是为第二层；企业创造了社会基因或者思想基因，可以跨界影响到整个行业乃至社会，实现横向传承，是为第三层。</p>
<p>今天的“最佳方法”可能会把我们引入死胡同，而最佳途径是未经尝试的新路径。科技是神奇的，它能事半功倍，将我们的基础能力提升到一个新的高度。成功人士总能在意想不到的地方发现价值，他们遵循的是基本原则，而非秘籍。</p>
<p>在什么重要问题上，你与其他人有不同看法？</p>
<p>大部分人认为世界的未来由全球化决定，但事实是——科技更有影响力。没有科技创新，也许中国能源产量在未来20年会加倍，但造成的污染也会加倍。如果印度亿万家庭也都像现在的美国家庭那样生活——只用现代工具，结果也将是对环境造成毁灭性的破坏。如果全世界都用同一种旧方法创造财富，那么创造的不是财富，而是灾难。在资源稀缺的今天，丢掉科技创新的全球化不会长久。</p>
<p>在功能极端失调的组织中，要想获得晋升机会，告诉别人你在工作比挽起袖子做事更重要。</p>
<p>最反主流的行动不是抵制潮流，而是在潮流中不丢弃自己的独立思考。</p>
<p>多家航空公司之间存在竞争，但是谷歌却只有一家。经济学家用两个简单模型解释了这两种现象：一是完全竞争，二是垄断。所以，如果你想创造并获得持久的价值，不要只是跟风建立一个没有特色的企业。</p>
<p>非垄断者通过把他们的市场定义成各种更小市场的交集来夸大自己的独特性；相反，垄断者通过描述若干大市场的并集来伪装他们的垄断性。</p>
<p>成功企业的特性————即使严守道德，也不会影响公司发展。垄断者除了想着赚钱外还有余力想着其他事情，而非垄断者就不行。在完全竞争中，企业着眼于短期利益，不可能对未来进行长期规划。要想将企业从每日的生存竞赛中解脱出来，唯一方法就是：获取垄断利益。</p>
<p>托尔斯泰在《安娜卡列尼娜》中以下面这段文字开头：“幸福的家庭总是相似的，不幸的家庭各有各的不幸。”而在商业中，情形恰恰相反。企业成功的原因各不同：每个垄断企业都是靠解决一个独一无二的问题获得垄断地位，而企业失败的原因却相同：它们都无法逃脱竞争。</p>
<p>竞争是一场高成本的买卖。竞争使我们过分重视过去的机会，一味重复过去的模式。竞争意味着大家都没有利润，产品没有实质差异，而且还要挣扎求生。创造性垄断就是新产品既让大众受益，又可以给创造者带来长期利润。</p>
<p>胜利肯定比失败好，但如果这场战役不值得打，那每个参与者就都是输家。有时你不得不投入战斗。需要的时候，你不仅要战斗，还必须得赢，没有中间选择：要么和风细雨润物无声，要么暴风骤雨速战速决。</p>
<p>一个企业的今天价值是它以后创造利润的总和。科技公司通常是开始几年亏损。因为创造有价值的东西需要时间，所以收益延迟。</p>
<p>垄断企业的特点：</p>
<ul>
<li>专利技术</li>
<li>网络效应</li>
<li>规模经济</li>
<li>品牌优势</li>
</ul>
<p>建立垄断企业的方法：</p>
<ul>
<li>占领小市场</li>
<li>扩大规模</li>
<li>破坏性创新</li>
</ul>
<p>初创企业是你可以明确掌握尽最大努力的机会。你不只拥有自己生命的代理权，还拥有这世界上某个重要角落的代理权。而这一切都要从抵制不公平的概率主宰开始，因为你并不是一张概率决定命运的彩票。</p>
<h1 id="再说一句"><a href="#再说一句" class="headerlink" title="再说一句"></a>再说一句</h1><p>从0到1，知易行难，但是做一个改变世界的逆行者，是我能想象到的世界上最酷的事情，彼得蒂尔做到了，而且不止一次！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;paypal_team.jpg&quot; alt=&quot;paypal team&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我的生活里充满了套路：&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="社科" scheme="http://zerosoul.github.io/tags/%E7%A4%BE%E7%A7%91/"/>
    
      <category term="彼得蒂尔" scheme="http://zerosoul.github.io/tags/%E5%BD%BC%E5%BE%97%E8%92%82%E5%B0%94/"/>
    
      <category term="商业与未来" scheme="http://zerosoul.github.io/tags/%E5%95%86%E4%B8%9A%E4%B8%8E%E6%9C%AA%E6%9D%A5/"/>
    
  </entry>
  
  <entry>
    <title>如何获取谷歌浏览器的独立安装包</title>
    <link href="http://zerosoul.github.io/2016/05/11/download-chrome-standalone/"/>
    <id>http://zerosoul.github.io/2016/05/11/download-chrome-standalone/</id>
    <published>2016-05-11T15:37:26.000Z</published>
    <updated>2016-06-17T05:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="chrome.jpg" alt="chrome pic"></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>已经N久没有更新过Chrome了，听说版本号都到了50+，我却还停留在40+。工欲善其事必先利其器，可是问题来了：Chrome自带的更新功能在我机器上失效！</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>有问题了就要想办法解决，最为简单粗暴的方式便是重装Chrome。于是跑到官网（需翻墙），下载安装包。其实下载下来的安装包是个在线安装包，所以很小，这种思路挺好，但是问题又来了：在线安装包的进度条一直处于“进度中”，看来又是卡在了某个网络连接上。</p>
<p>Chrome有没有独立安装包？抱着这个想法在官网找了找有没有下载入口，很遗憾没找到。于是祭出Google大法：使用关键词<strong>chrome download standalone</strong>搜索，从结果中很快找到了预期的解决方法：<a href="http://www.askvg.com/official-link-to-download-google-chrome-standalone-offline-installer/" target="_blank" rel="external">Official Link to Download Google Chrome Full Standalone Offline Installer</a>。其实很简单，在官网链接后面加参：<code>standalone=1</code>，然后按照正常方式下载，便是下载的独立安装包。不过需要注意的是：默认下载的平台是<code>Windows 32-bit</code>，如果需要<code>Windows 64-bit</code>，那再加个参：<code>platform=win64</code>，如果需要<code>Mac</code>平台版本，加参：<code>platform=mac</code>。</p>
<p>独立安装包下载完，走一遍正常的安装程序，一切搞定！</p>
<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>其他小伙伴可能也遇到过这样的小问题，所以花了点时间把我是如何解决这个问题的写了下来。有些简单粗暴，不过有时候遇到问题不一定非得去针对这个具体问题去解决，换个思路或许能成本更小地解决问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;chrome.jpg&quot; alt=&quot;chrome pic&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;已经N久没有更新过Chrome了，听说版本号都
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://zerosoul.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Chrome" scheme="http://zerosoul.github.io/tags/Chrome/"/>
    
      <category term="翻墙" scheme="http://zerosoul.github.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="小记" scheme="http://zerosoul.github.io/tags/%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP的Node.js之旅</title>
    <link href="http://zerosoul.github.io/2016/04/29/Anatomy-of-an-HTTP-Transaction/"/>
    <id>http://zerosoul.github.io/2016/04/29/Anatomy-of-an-HTTP-Transaction/</id>
    <published>2016-04-29T07:48:52.000Z</published>
    <updated>2016-05-01T02:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http.jpg" alt="http"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天node.js发布了新版本，想看看具体更新了啥，于是去<a href="http://nodejs.org" target="_blank" rel="external">官网</a>找changelog看了看，顺便逛了逛其它栏目。没想到，在DOCS下的<a href="https://nodejs.org/en/docs/guides/" target="_blank" rel="external">Guides</a>发现了一篇好文，讲的是node.js对http请求的处理过程，虽然不是很适合初学者，但顺藤摸瓜，能挖掘出许多知识点，串联起来，干货满满。下面是译文，没有逐字逐句翻译，有添油加醋的地方，但不影响原文的表达。</p>
<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><p>这篇文章目的在于阐释HTTP请求在node.js中的处理过程。所以前提是假定你知道HTTP为何物，并且对node.js的<a href="https://nodejs.org/api/events.html" target="_blank" rel="external">EventEmitters</a>和<a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">Streams</a>有所了解，否则，最好快速过一下有关的<a href="https://nodejs.org/dist/latest-v6.x/docs/api" target="_blank" rel="external">API</a>。</p>
<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>任何一个node web server在代码某一处都会通过<a href="https://nodejs.org/api/http.html#http_http_createserver_requestlistener" target="_blank" rel="external">createServer</a>创建一个web服务器对象.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="comment">// 见证奇迹的时刻</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>作为参数传入<code>createServer</code>的函数是http请求必由之路，因此也叫作请求处理函数。事实上，<code>createServer</code>返回的<code>server</code>对象是一个<code>EventEmitter</code>，因此，上面那段代码也可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = http.createServer();</div><div class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="comment">// 见证奇迹的时刻</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当请求来临时，node.js会调用请求处理函数，并且封装好了两个常用对象：<strong>request</strong>和<strong>response</strong>。稍后我们会经常碰到这两个家伙的。</p>
<p>花开两朵，各表一枝。为了能够接收到http请求，还需要调用<code>server</code>对象的<code>listen</code>方法。多数情况下，你只需要传给<code>listen</code>一个端口号。还有一些其他设置，感兴趣的话请参考<a href="https://nodejs.org/api/http.html" target="_blank" rel="external">这里</a></p>
<h2 id="Method-URL-和-Headers"><a href="#Method-URL-和-Headers" class="headerlink" title="Method,URL 和 Headers"></a>Method,URL 和 Headers</h2><p>处理一个请求时，你想知道的第一件事可能就是看一下这个请求的<code>method</code>和<code>url</code>，然后才会有相应的处理。node.js把这两个信息放在了<code>request</code>对象里了，直接调用即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> method = request.method;</div><div class="line"><span class="keyword">var</span> url = request.url;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注:request 对象是 <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="external">IncommingMessage</a>的一个实例</p>
</blockquote>
<p><code>Headers</code>也在<code>request</code>对象里：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> headers = request.headers;</div><div class="line"><span class="keyword">var</span> userAgent = headers[<span class="string">'user-agent'</span>];</div></pre></td></tr></table></figure></p>
<p>需要注意的是，无论客户端发送的是什么，node.js把所有的头信息关键词都小写化了。变单一的同时也就减少了因分歧出错的可能性。还有，如果有重复的头信息，有些会重写，有些会使用<code>,</code>合并成字符串。在一些场景可能会出现问题，没关系，<code>request</code>中还有个<a href="https://nodejs.org/api/http.html#http_message_rawheaders" target="_blank" rel="external">rawHeaders</a>，你值得拥有。</p>
<h2 id="Request-Body（请求体）"><a href="#Request-Body（请求体）" class="headerlink" title="Request Body（请求体）"></a>Request Body（请求体）</h2><p>当请求方法是<code>PUT</code>或者<code>POST</code>时，请求体就成了重点关注对象。获取请求体，相对于获取上面那三个值，就需要多知道点了：<code>request</code>对象实现了<a href="https://nodejs.org/api/stream.html#stream_class_stream_readable" target="_blank" rel="external">ReadableStream</a>接口，所以能够被监听或者管道化。因此，我们可以通过监听<code>data</code>和<code>end</code>事件来获取流内数据。</p>
<p><code>data</code>过来的数据块都是<a href="https://nodejs.org/api/buffer.html" target="_blank" rel="external">Buffer</a>。如果你清楚的知道传输过来的数据是字符串，那么最好将它们存放在一个数组里，在<code>end</code>事件中，合并(concatenate)并字符串化(stringify)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> body = [];</div><div class="line">request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  body.push(chunk);</div><div class="line">&#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  body = Buffer.concat(body).toString();</div><div class="line">  <span class="comment">// 代码执行到这里，body就拥有了整个字符串形式的数据了。</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>注：多数情况下，这样做有些啰嗦。幸运的是，npm上有许多能将这些逻辑隐藏的优秀模块，比如<a href="https://www.npmjs.com/package/concat-stream" target="_blank" rel="external">concat-stream</a>和<a href="https://www.npmjs.com/package/body" target="_blank" rel="external">body</a>。即便如此，还是希望能够好好理解一下这个细节，因为这属于基础。</p>
</blockquote>
<h2 id="有关错误（Errors）"><a href="#有关错误（Errors）" class="headerlink" title="有关错误（Errors）"></a>有关错误（Errors）</h2><p>既然<code>request</code>是一个<code>EventEmitter</code>，那么当有错误时，就可以触发<code>error</code>事件。<strong>如果你没有监听这个事件，错误会被抛出，进而很可能导致node.js程序的崩溃。</strong>所以，最佳实践便是给<code>request</code>增加<code>error</code>事件，在事件回调函数里面做一下日志记录的同时，最好给客户端返回对应的错误码，这个在后面会提到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">  <span class="comment">// console的错误标准输出</span></div><div class="line">  <span class="built_in">console</span>.error(err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>有关错误的处理，还有其它方式，可以参考<a href="https://nodejs.org/api/errors.html" target="_blank" rel="external">这里</a>。记住，错误随时会发生，要对此有所警惕，对其有专门的处理总是好的。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>走到这里，我们已经创建了一个web服务器，获取到了请求的<code>method</code>，<code>url</code>和<code>headers</code>，哦，还有请求体内容。现在我们将这些放在一起：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> headers = request.headers;</div><div class="line">  <span class="keyword">var</span> method = request.method;</div><div class="line">  <span class="keyword">var</span> url = request.url;</div><div class="line">  <span class="keyword">var</span> body = [];</div><div class="line">  request.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    body = Buffer.concat(body).toString();</div><div class="line">    <span class="comment">// 至此，我们就获取到了所有需要响应给客户端的数据</span></div><div class="line">  &#125;);</div><div class="line">&#125;).listen(<span class="number">8080</span>); <span class="comment">// Activates this server, listening on port 8080.</span></div></pre></td></tr></table></figure></p>
<p>很显然，如果运行这个代码，服务器能接收到请求（request），但没发出响应（response）。也就是说，在浏览器里面发出请求，会超时。</p>
<p>目前为止，我们还未碰触<code>response</code>对象，它是<a href="https://nodejs.org/api/http.html#http_class_http_serverresponse" target="_blank" rel="external">ServerResponse</a>的一个实例，也是一个<a href="https://nodejs.org/api/stream.html#stream_class_stream_writable" target="_blank" rel="external">WritableStream</a>，为了将数据传回客户端，其中包含了许多实用方法。好吧，依旧是花开两朵，各表一枝，我们先认识下http状态码，待会儿再谈<code>response</code>对象。</p>
<h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p><code>response</code>默认状态码是<code>200</code>。当然，有些情况下，你需要返回不同的状态码。<code>response</code>中的<code>statusCode</code>属性就是为此存在的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.statusCode = <span class="number">404</span>;<span class="comment">//告诉客户端资源未找到...</span></div></pre></td></tr></table></figure></p>
<h2 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h2><p><code>response</code>中的<code>setHeader</code>该出场了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.setHeader(<span class="string">'Content-Type'</span>,<span class="string">'application/json'</span>);</div><div class="line">response.setHeader(<span class="string">'X-Powered-By'</span>,<span class="string">'bacon'</span>);</div></pre></td></tr></table></figure></p>
<p>需要注意的是，响应头关键词对大小写不敏感，如果重复设置一个响应头，那么客户端取到的是你最后一个。</p>
<h2 id="显式发送响应头"><a href="#显式发送响应头" class="headerlink" title="显式发送响应头"></a>显式发送响应头</h2><p>上面提到的<code>statusCode</code>和<code>setHeader</code>属于<strong>隐式头部</strong>：意思是在发送body数据前，依赖的是node.js来发送头部数据。</p>
<p>如果你愿意，也可以显式地将头部信息写到响应流里。<code>writeHead</code>便是为此而生：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response.writeHead(<span class="number">200</span>, &#123;</div><div class="line">  <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</div><div class="line">  <span class="string">'X-Powered-By'</span>: <span class="string">'bacon'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>设置完头部，接下来便是发送响应数据了。</p>
<h2 id="发送响应数据"><a href="#发送响应数据" class="headerlink" title="发送响应数据"></a>发送响应数据</h2><p>既然<code>response</code>对象是个<code>WritableStream</code>，那么就可以使用流方法来向客户端写数据了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">response.write(<span class="string">'&lt;html&gt;'</span>);</div><div class="line">response.write(<span class="string">'&lt;body&gt;'</span>);</div><div class="line">response.write(<span class="string">'&lt;h1&gt;Hello, World!&lt;/h1&gt;'</span>);</div><div class="line">response.write(<span class="string">'&lt;/body&gt;'</span>);</div><div class="line">response.write(<span class="string">'&lt;/html&gt;'</span>);</div><div class="line">response.end();</div></pre></td></tr></table></figure></p>
<p>以上代码也可以简写成以下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.end(<span class="string">'&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注:响应体在响应头之后，因此往response里写数据之前就设置好状态码和头信息，一切才会有意义。</p>
</blockquote>
<h2 id="Response的错误处理"><a href="#Response的错误处理" class="headerlink" title="Response的错误处理"></a>Response的错误处理</h2><p>与<code>request</code>一样，<code>response</code>也会触发<code>error</code>事件。所以，有关<code>request</code>错误处理最佳实践，同样也适用于<code>response</code>。</p>
<h2 id="再来小结一下"><a href="#再来小结一下" class="headerlink" title="再来小结一下"></a>再来小结一下</h2><p>目前来讲，我们已经不会让浏览器傻等了。那么，把所有代码放在一起，我们可以做到让服务端把浏览器过来的请求组织下数据再传送过去，注意，使用<code>JSON.stringify</code>格式化了下数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> headers = request.headers;</div><div class="line">  <span class="keyword">var</span> method = request.method;</div><div class="line">  <span class="keyword">var</span> url = request.url;</div><div class="line">  <span class="keyword">var</span> body = [];</div><div class="line">  request.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    body = Buffer.concat(body).toString();</div><div class="line">    <span class="comment">// BEGINNING OF NEW STUFF</span></div><div class="line"></div><div class="line">    response.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.error(err);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    response.statusCode = <span class="number">200</span>;</div><div class="line">    response.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</div><div class="line">    <span class="comment">// 注：上面两行代码可以用下面一行替换</span></div><div class="line">    <span class="comment">// response.writeHead(200, &#123;'Content-Type': 'application/json'&#125;)</span></div><div class="line"></div><div class="line">    <span class="keyword">var</span> responseBody = &#123;</div><div class="line">      headers: headers,</div><div class="line">      method: method,</div><div class="line">      url: url,</div><div class="line">      body: body</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    response.write(<span class="built_in">JSON</span>.stringify(responseBody));</div><div class="line">    response.end();</div><div class="line">    <span class="comment">// 注：同样，可以这样替换</span></div><div class="line">    <span class="comment">// response.end(JSON.stringify(responseBody))</span></div><div class="line"></div><div class="line">    <span class="comment">// END OF NEW STUFF</span></div><div class="line">  &#125;);</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<h2 id="Echo-服务器"><a href="#Echo-服务器" class="headerlink" title="Echo 服务器"></a>Echo 服务器</h2><p>基于上面代码，我们可以简化一下，做出一个Echo服务器，即请求什么数据，就返回什么数据。我们只需要从请求里面获取数据并写到响应里，和上面代码差不多：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> body = [];</div><div class="line">  request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">    body.push(chunk);</div><div class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    body = Buffer.concat(body).toString();</div><div class="line">    response.end(body);</div><div class="line">  &#125;);</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>好吧，有些过于简单，我们再增加两个需求，满足下面两个条件才给出正确响应：<br>1.请求的<code>method</code>是<code>GET</code><br>2.URL是<code>/echo</code><br>否则给出<code>404</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (request.method === <span class="string">'GET'</span> &amp;&amp; request.url === <span class="string">'/echo'</span>) &#123;</div><div class="line">    <span class="keyword">var</span> body = [];</div><div class="line">    request.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">      body.push(chunk);</div><div class="line">    &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      body = Buffer.concat(body).toString();</div><div class="line">      response.end(body);</div><div class="line">    &#125;)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    response.statusCode = <span class="number">404</span>;</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：检查URL，实质上就是一种路由<code>routing</code>形式。其它形式有简单如<code>swtich</code>语句，复杂如<strong><a href="https://www.npmjs.com/package/express" target="_blank" rel="external">Express</a></strong>框架。如果需要纯路由功能，可以试试[Router][<a href="https://www.npmjs.com/package/router]。" target="_blank" rel="external">https://www.npmjs.com/package/router]。</a></p>
</blockquote>
<p>上面的代码能不能再精简下呢？别忘了，<code>request</code>对象是一个<code>ReadableStream</code>，<code>response</code>对象是一个<code>WritableStream</code>。这意味着可以使用管道（pipe）直接将数据从一端传到另一端。所以，更为精简的代码诞生了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (request.method === <span class="string">'GET'</span> &amp;&amp; request.url === <span class="string">'/echo'</span>) &#123;</div><div class="line">    request.pipe(response);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    response.statusCode = <span class="number">404</span>;</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>事情还没完，程序出错了怎么办？好吧，加上错误处理机制：在此，我们仅仅打印出错误，并将状态码置为<code>404</code>。（更为详细的错误处理机制可以参考<a href="https://nodejs.org/api/errors.html" target="_blank" rel="external">这里</a>）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">  request.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">    response.statusCode = <span class="number">400</span>;</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line">  response.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">if</span> (request.method === <span class="string">'GET'</span> &amp;&amp; request.url === <span class="string">'/echo'</span>) &#123;</div><div class="line">    request.pipe(response);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    response.statusCode = <span class="number">404</span>;</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;).listen(<span class="number">8080</span>);</div></pre></td></tr></table></figure></p>
<p>OK，node.js如何处理http请求，目前为止，我们已经把大部分的基础知识讲解到了。最后，我们总结下这些知识点：</p>
<ol>
<li>实例化一个HTTP服务器，并设置一个请求处理函数，另外别忘了监听一个端口</li>
<li>从<code>request</code>获取<code>headers</code>,<code>url</code>,<code>method</code>,<code>body</code>等信息</li>
<li>根据<code>url</code>或者其它信息路由</li>
<li>通过<code>response</code>发送响应头、状态码和数据</li>
<li><code>request</code>数据管道化到<code>response</code></li>
<li>对<code>request</code>和<code>response</code>设置错误处理机制</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>原文链接：<a href="https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/" target="_blank" rel="external">Anatomy of an HTTP Transaction</a></li>
<li><a href="https://nodejs.org/api/events.html" target="_blank" rel="external">EventEmitters</a></li>
<li><a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">Streams</a></li>
<li><a href="https://nodejs.org/api/http.html" target="_blank" rel="external">HTTP</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http.jpg&quot; alt=&quot;http&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天node.js发布了新版本，想看看具体更新了啥，于是去&lt;
    
    </summary>
    
      <category term="它山之石" scheme="http://zerosoul.github.io/categories/%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3/"/>
    
    
      <category term="译文" scheme="http://zerosoul.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="技术" scheme="http://zerosoul.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="node.js" scheme="http://zerosoul.github.io/tags/node-js/"/>
    
      <category term="http" scheme="http://zerosoul.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>读《富爸爸穷爸爸》</title>
    <link href="http://zerosoul.github.io/2016/04/16/Financial-IQ/"/>
    <id>http://zerosoul.github.io/2016/04/16/Financial-IQ/</id>
    <published>2016-04-16T12:02:00.000Z</published>
    <updated>2016-04-24T08:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="fubaba.jpg" alt="富爸爸"></p>
<blockquote>
<p>财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久。  –巴克敏斯特.富勒</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>美国作家罗伯特清崎写的<a href="https://book.douban.com/subject/1033778/" target="_blank" rel="external">《富爸爸穷爸爸》</a>是本老书了，因为在我的记忆里，自家小书店很久就有这本书了，而且属于积压货，对，就是连我都不屑翻看的那种积压货。前段时间有同事推荐一读，于是买来就一直放着，最近两天才拿起。差点被这沾满铜臭味的书名欺骗了，其实不谈钱就像迷恋钱一样，是一种精神上的疾病，书中所讲的一些观点还是值得深思与实践的。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>罗伯特清崎从人的个体出发分析富人之所以成为富人，穷人之所以成为穷人，提出了一个全新的“财商”的概念，并向学校教育提出挑战。清崎有两个爸爸，一个有博士学位是他的亲生爸爸，也就是本书中的穷爸爸，另外一个初中都没有读完是他好友的爸爸，即富爸爸。两个爸爸都有非常高的收入，但是穷爸爸却常为钱所烦恼，而富爸爸最终成为了夏威夷最富有的人，并在过世后给家人留下了很多财产，而穷爸爸则给家人留下了很多还没有还清的债务。之所以会出现这种情况，是因为穷爸爸缺乏基本的财务知识，而关于财商的培养最大的问题是学校没有教授过这门学科，即使穷爸爸是博士学位。有关财商的教育基本是来自家庭，这就造成了穷人家庭接受的是穷人思维，富人更富有创造性，愿意经过精心筹划后再去冒险，阶级自此划分。</p>
<p>我们从小就被教育说：好好上学，毕业了找份好工作，但几乎从未认真思考过这样一个问题：好好读书就可以找到好工作吗，找到好工作就可以变富有吗。现在来看，尤其是工作几年后，答案应该都是否定的。真相是天天为金钱而忙碌，一旦陷入这种虚假的忙碌陷阱，就和那些蹬着小铁笼不停转圈的老鼠一样，它们的小毛腿蹬得飞快，小铁笼也转的飞快，可到了第二天早上，发现自己依然被困在笼子里，就像你被你的工作困住一样。这样的生活毫无意义，疲于奔命却摆脱不了贫困的现实。，那么，为什么不能让金钱为我们工作呢？学会管理风险与投资，似乎是走向这条道路的第一步。把金钱看得越重，就会为金钱工作得越辛苦，如果知道“金钱不是真实的资产”这一道理，小铁笼似乎就开始松垮了…</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>如果你和我一样并没有出身在那1%的家庭，可以学习作者向富爸爸学习的知识：首先，必须要了解两个词<strong>资产</strong>和<strong>负债</strong>。资产就是能把钱放入自己口袋的东西，而负债就是把钱从口袋里取走的东西。任何东西都可以是资产，也可以是负债。比如说你拥有一套房子，每个月要支付3000元，那这套房子就是负债，而如果租出去每月能带来3000元房租，那它就是你的一项资产了。了解这两者的差别非常重要，因为穷人花钱只有消费，没有购置资产的意识，富人花钱则是买进资产，而中产阶级花钱买自以为是资产的负债。</p>
<p>毕业后在求职大军里谋得一份工作，于是就有了收入，随着经验的丰富，薪水提高了，但更多的问题产生了，会面临着买房买车，也会想换一个iPhone 6s，于是就开始买入自以为是资产的负债，每个月要为房子还贷，为车子加油，为电话缴费，除非对金钱的思维方式作出重大改变，也就是买能把钱放进口袋的资产，不然无论薪水有多高，钱都会比必要支出多出那么一点点而已。朋友可能会羡慕你的最新款手机，但实际上并没有钱，只是看起来很有钱罢了。</p>
<p>如果跟随上学然后上班的道路，那么在继续工作的同时，要确保辛苦赚来的钱投入在购买真正的资产而非看起来像资产的负债上，当资产产生的收入，这好像叫<strong>被动收益</strong>，高于你的支出，那就不再需要这份工作了，进而达到了财务自由的境界。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>学校是生产好雇员而非好雇主的地方，当前的教育体系致力于让学生学习知识并找到好工作，一旦从学校走出，每个人便不得不贴上职业标签：程序员，销售员，工程师，科学家，厨师，警察等等。成为工薪阶层，并为钱而工作，但是只局限于所学专业的可怕后果在于：它会让你忘记关注自己的事业，反而耗尽一生去关注别人的事业，也就是老板的事业，并使他人致富。而自己的事业重心是资产项，而不是收入项，正如前面说过的秘诀是要知道资产与负债的区别，并且去买入资产。富人关心的是资产，而其他人关心的是收入，如果我们学习掌握一些财务知识，在通向财务自由的路上还是会面临许多的障碍：</p>
<ol>
<li>恐惧心理</li>
<li>愤世嫉俗</li>
<li>懒惰</li>
<li>不良习惯</li>
<li>自负</li>
</ol>
<p>如果我们知道自己在哪一个问题上有所欠缺，那最好找本领域的相关书籍好好学习克服我们所面临的困难。解决了这五个问题就可以开始行动了：</p>
<ul>
<li>首先要有发自内心深处的精神动力，如果促使前进的动力不够强大，那么前行道路上的严酷现实就会退缩，所以必须要有一个强有力的理由和目标，只有这样才会有持续前进的动力。</li>
<li>行动中也要明白关系的力量，也就是朋友圈。当然不应该把金钱当成挑选朋友的唯一标准，朋友中可以有穷困潦倒的，也有财务自由的，三人行必有我师焉，学习每个人身上的优点，与有钱的朋友交往并非是为了得到他们的钱财，而是学习他们得以致富的方法和知识。</li>
<li>掌握一种模式，然后再学习一种新的模式，重要的是要学会快速学习。在钱的问题上，大多数人只知道一个基本的挣钱模式，这个模式在学校就已经奠定，就是为了金钱工作，每天数以亿计的人起床上班挣钱还贷支付账单，如果对自己所做的工作感到厌倦或是觉得挣得不多，那么可以尝试下改变你的挣钱模式，</li>
<li>学会控制自己，也就是自律，首先支付自己，当资金短缺时，让压力发挥作用，而不要动用储蓄或资本。</li>
</ul>
<h1 id="五"><a href="#五" class="headerlink" title="五"></a>五</h1><p>在今天这个日新月异的社会中，如果想找一个赚钱的方法机会很多，可以先停下来评估下自己的做法中哪些有效，哪些无效，在学习中寻找新的思想和新的赚钱模式。上天赐予每个人两样伟大礼物：思想和时间。运用这两件礼物去做愿意做的事情吧，比如致富。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;fubaba.jpg&quot; alt=&quot;富爸爸&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;财富就是支撑一个人生存多长时间的能力，或者说，如果我今天停止工作，我还能活多久。  –巴克敏斯特.富勒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一&quot;&gt;&lt;a 
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="理财" scheme="http://zerosoul.github.io/tags/%E7%90%86%E8%B4%A2/"/>
    
      <category term="富爸爸穷爸爸" scheme="http://zerosoul.github.io/tags/%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8/"/>
    
      <category term="财商" scheme="http://zerosoul.github.io/tags/%E8%B4%A2%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>读《激荡三十年》</title>
    <link href="http://zerosoul.github.io/2016/04/10/about-chinese-business/"/>
    <id>http://zerosoul.github.io/2016/04/10/about-chinese-business/</id>
    <published>2016-04-10T14:31:44.000Z</published>
    <updated>2016-04-24T08:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="acb.jpg" alt="lost man"></p>
<blockquote>
<p>成功是一种了不起的除臭剂，它可以去除你过去所有的气味。<br>                                        ——伊丽莎白.泰勒，美国影星</p>
</blockquote>
<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>《英国简史》作者伍德沃德曾经写道：“历史涉及的只是一个民族生活的极小部分，人民的大部分生活和艰辛创业，过去和未来都不会有文字记载”。他还引用<a href="http://www.zwbk.org/MyLemmaShow.aspx?lid=296672" target="_blank" rel="external">《便西拉智训》</a>中的一段名句说：“有的人湮没无闻，他们死去，无人知晓，仿佛他们从未来过这个世界一样”。作为历史小白，总想了解下中国当代历史细节，于是在偶然的际遇，去年大概六月份入手了一套<a href="http://baike.baidu.com/subview/701659/7602430.htm" target="_blank" rel="external">吴晓波</a>编著的《激荡三十年》，上下两册，外加一本珍藏版的纪实画册，没想到这套书成为了我的商业启蒙读物。</p>
<h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>断断续续大概用了多半年的阅读时间，最近又拿起快速重温一遍：</p>
<p>全书组织以编年形式，每一年为一章。而每一章中，选择重要政策变化进行解读，再辅以全国经济形势的阐述，热点社会事件再现，另穿插以典型企业家，在若干相关章节中连续提起，使各章节间既有历史逻辑性连贯，又有人物或企业命运的连贯，读起来手不释卷。另外，在每一章结尾，又附有一二人物传记，更将突出的典型人物着力描绘。如此写法，不光是书的可读性强，在理论上也使得我所感兴趣的宏观与微观之间的联系得以展示，且相互解释，不得不佩服作者深厚的研究功底和文学修养。</p>
<h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>股市之狂热，楼市之飙升，人民币之升值，通货膨胀之隐患，贸易摩擦之激烈以及大国情结之高昂，每每让人想起那句名言：历史往往是重复的，只是经常以另一种方式呈现出来罢了。</p>
<p>在这片神奇的土地，以下描述一再被证实：任何被视为奇迹的事物，往往都很难延续，因为它经历的是非常规的历程，身处其中的人们，因此而获得巨大利益，每每不可能摆脱那些终身难忘的际遇，他们相信那就是命运，总希望每次都能鸿运高照，每次都能侥幸胜出，然而最后，所有的光荣往往枯萎在自己的光环中。</p>
<p>所以，当一个商业故事以无比圆滑和生动的姿态出现在你面前的时候，首先必须怀疑，而所有的怀疑，最终都会被证明是正确的，或者至少是值得的。</p>
<p>也许在多年后回望，人们会说，这激荡的30年是一个多么世俗的年代，人人以物质追求为目标，道德底线被轻易打破，心灵焦虑无处不在，身份认同时常颠覆。所有的财富故事都暧不清，很多企业家前途叵测，挣扎在产权灰色地带，不能自拔。</p>
<p>但同时不得否认的是，30年催生了一个时代的伟岸和壮观，也同样滋养了世故，丑陋和空虚。我们遭遇的是一个空前复杂而大半面目未清的时代。急速变化的世界，怅然若失的个人命运，传统与现代，个人与群体，不同利益集团的冲撞和拷问，这是30年成长底色。</p>
<p>尽管充斥着种种抱怨，失落和焦虑，但是，仍然要说，那是一个好的时代。因为，它允许新的可能性发生。</p>
<h1 id="四"><a href="#四" class="headerlink" title="四"></a>四</h1><p>成功，在中国已经是一个烂大街的名词。人人都在渴望，却终究不得其法。历史一再告诫我们：毁灭的种子是什么？第一个就是繁荣自身。那么我们这代人何去何从？作为一名技术从业者，似乎在互联网公司看到了些许希望：既无模糊产权之累、又无灰色创业之原罪、也无国有垄断企业之压迫，且还在竞争中屡屡击败跨国公司。</p>
<p>写到此，我惊喜地发现自己在以一个从未有过的角度来思考问题，正如法国人<a href="http://baike.baidu.com/view/83542.htm" target="_blank" rel="external">罗兰巴特</a>所说：“我对不太可能发生的事，以及历史的本质始终迷惑不解”。阅读当代史的快感和诡异，便全在这里了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;acb.jpg&quot; alt=&quot;lost man&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成功是一种了不起的除臭剂，它可以去除你过去所有的气味。&lt;br&gt;                                        ——伊丽莎白.泰勒，美
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="激荡三十年" scheme="http://zerosoul.github.io/tags/%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4/"/>
    
      <category term="中国企业史" scheme="http://zerosoul.github.io/tags/%E4%B8%AD%E5%9B%BD%E4%BC%81%E4%B8%9A%E5%8F%B2/"/>
    
      <category term="吴晓波" scheme="http://zerosoul.github.io/tags/%E5%90%B4%E6%99%93%E6%B3%A2/"/>
    
  </entry>
  
  <entry>
    <title>探索Object.assign()</title>
    <link href="http://zerosoul.github.io/2016/03/25/explore-object-assign/"/>
    <id>http://zerosoul.github.io/2016/03/25/explore-object-assign/</id>
    <published>2016-03-25T09:17:47.000Z</published>
    <updated>2016-06-27T07:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="obj.jpg" alt="extend obj"></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在重构以前写过的<strong>javascript</strong>代码，目的是为了去掉对<strong>jQuery</strong>的依赖。其中有多处用到了<a href="http://api.jquery.com/jQuery.extend/" target="_blank" rel="external"><code>$.extend()</code></a>方法，自然而然会想到这么一个问题：如何用自己的方式来实现？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先，定义函数的功能：<strong>传入多个对象，将多个对象的内容合并到第一个对象中，最后返回合并后的对象，即参数中的第一个对象。</strong>这样的定义是否似曾相识？没错，和ES6中的新特性<code>Object.assign()</code>几乎一模一样。所以，可以从探索<code>Object.assign()</code>开始。</p>
<h1 id="探索Object-assign"><a href="#探索Object-assign" class="headerlink" title="探索Object.assign()"></a>探索Object.assign()</h1><p><code>Object.assign(target, ...sources)</code></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="拷贝对象"><a href="#拷贝对象" class="headerlink" title="拷贝对象"></a>拷贝对象</h3><p>只需要传入的第一个参数是空对象即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; foo: 1 &#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h3><p>注意第一个传参将会被改变，所以如果不想改变第一个有值参数，可以传入一个空对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123; a: <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">var</span> o2 = &#123; b: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> o3 = &#123; c: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(o1, o2, o3);</div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></div><div class="line"><span class="built_in">console</span>.log(o1);  <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意第一个参数，即o1有了变化。</span></div></pre></td></tr></table></figure></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>在<code>Object.assign()</code>中，原型属性和非可枚举属性不会被拷贝。（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties" target="_blank" rel="external">两种属性的解释</a>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123; foo: <span class="number">1</span> &#125;, &#123; <span class="comment">// foo是obj原型链上的属性</span></div><div class="line">  bar: &#123;</div><div class="line">    value: <span class="number">2</span>  <span class="comment">// bar 是非可枚举（non-enumerable）属性.</span></div><div class="line">  &#125;,</div><div class="line">  baz: &#123;</div><div class="line">    value: <span class="number">3</span>,</div><div class="line">    enumerable: <span class="literal">true</span>  <span class="comment">// baz是可枚举属性.</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; baz: 3 &#125;，只拷贝了baz属性</span></div></pre></td></tr></table></figure>
<ul>
<li>元类型会被转化为对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> v1 = <span class="string">'abc'</span>;</div><div class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</div><div class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, <span class="literal">null</span>, v2, <span class="literal">undefined</span>, v3); </div><div class="line"><span class="comment">//元类型里面的字符串被转化为字符数组，null和undefined被忽略</span></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; "0": "a", "1": "b", "2": "c" &#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>异常会抛出，但是已经执行的代码会生效</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">'foo'</span>, &#123;</div><div class="line">  value: <span class="number">1</span>,</div><div class="line">  writable: <span class="literal">false</span></div><div class="line">&#125;); <span class="comment">// target.foo 为只读属性</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, &#123; bar: <span class="number">2</span> &#125;, &#123; foo2: <span class="number">3</span>, foo: <span class="number">3</span>, foo3: <span class="number">3</span> &#125;, &#123; baz: <span class="number">4</span> &#125;);</div><div class="line"><span class="comment">// 会抛出异常：TypeError: "foo" is read-only，但是之前的赋值操作已经生效。</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(target.bar);  <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(target.foo2); <span class="comment">// 3</span></div><div class="line"><span class="built_in">console</span>.log(target.foo);  <span class="comment">// 1, 异常就是在这儿发生的，所以还是1</span></div><div class="line"><span class="built_in">console</span>.log(target.foo3); <span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.log(target.baz);  <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h1 id="pollyfill"><a href="#pollyfill" class="headerlink" title="pollyfill"></a>pollyfill</h1><p>上面是对<code>Object.assign()</code>概念层面的探索，由于要考虑旧版本浏览器兼容性问题，需要写一个<strong>pollyfill</strong>，其实这才是重头戏。不过，只有理解了<code>Object.assign()</code>都干了些什么，才有可能写出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.assign != <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="built_in">Object</span>.assign = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</div><div class="line">      <span class="comment">//第一个传参不能是undefined和null，因为它们不能被转为对象</span></div><div class="line">        <span class="keyword">if</span> (target === <span class="literal">undefined</span> || target === <span class="literal">null</span>) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Can not convert undefined or null to object'</span>);</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//使用Object对象化target</span></div><div class="line">        <span class="keyword">var</span> output = <span class="built_in">Object</span>(target);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">1</span>,l=<span class="built_in">arguments</span>.length; index &lt; l; idx++) &#123;</div><div class="line">          <span class="keyword">var</span> source = <span class="built_in">arguments</span>[idx];</div><div class="line">          <span class="comment">//后续传参也需要判断undefined和null</span></div><div class="line">          <span class="keyword">if</span> (source !== <span class="literal">undefined</span> &amp;&amp; source !== <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</div><div class="line">              <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</div><div class="line">                output[key] = source[key];</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> output;</div><div class="line">      &#125;;</div><div class="line">&#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>好了，现在可以在宿主环境大胆使用<code>Object.assign()</code>了，Let’s rock it~~~</p>
<h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill" target="_blank" rel="external">MDN:Object.assign()</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;obj.jpg&quot; alt=&quot;extend obj&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;最近在重构以前写过的&lt;strong&gt;javascri
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="javascript" scheme="http://zerosoul.github.io/tags/javascript/"/>
    
      <category term="探索系列" scheme="http://zerosoul.github.io/tags/%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97/"/>
    
      <category term="ES6" scheme="http://zerosoul.github.io/tags/ES6/"/>
    
      <category term="jquery" scheme="http://zerosoul.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>读《人类简史》</title>
    <link href="http://zerosoul.github.io/2016/03/19/from-animal-to-god/"/>
    <id>http://zerosoul.github.io/2016/03/19/from-animal-to-god/</id>
    <published>2016-03-19T00:43:27.000Z</published>
    <updated>2016-04-24T08:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="renleijianshi.jpg" alt="人类简史"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>从认知革命、农业革命到科学革命，我们真的了解自己吗？</li>
<li>我们过得更加快乐吗？</li>
<li>我们知道金钱和宗教从何而来，为何产生吗？</li>
<li>人类创建的帝国为何一个接一个衰亡又兴起？</li>
<li>为什么地球上几乎每一个社会都有男尊女卑的观念？</li>
<li>为何一神教成为最为广泛接受的宗教？</li>
<li>科学和资本主义如何成为现代社会最重要的信条？</li>
</ul>
<p>如果说有这么一本书，能对上面的疑问进行探索与解答，并且做到让人折服，那么<strong>《人类简史》</strong>做到了。更重要的是，这本书竟然不到五百页，没有一堆令人晕头转向的年份、人名、地名、编号。看完这本书，有一种跟着人类一同走过十万年的感觉，见微知著、以小写大，重新审视自己。</p>
<p>就个人的切身感受来说，该书是不支持如饥似渴的阅读模式的，即便是笔者写的饶有趣味，但是以其深刻的内容，也使得读时必须要边看边想的琢磨，和消遣时看的小说不同，看这样的理论性书籍不只是要过脑子的，甚至还是需要动脑子的。本以为400多页的书，一天一小时的阅读时间，看个40页左右，怎么的10天下来也够看完的了，虽然很不好意思，到现在为止也没能完全消化，只能先写个一部分：认知革命。</p>
<h1 id="认知革命"><a href="#认知革命" class="headerlink" title="认知革命"></a>认知革命</h1><p>相对于后面章节所讲的<strong>农业革命、人类的融合与统一、科学革命</strong>，开篇所讲的认知革命给我带来了更多的启发与触动。因为自己这方面的知识十分匮乏，所以今天重点梳理下我对这本书认知革命章节的理解。</p>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>大约在250万年前，人类从东非开始演化，逐渐向世界各地扩散，受地域气候自然条件等等外界因素的影响，人类进化出了许多品种，就像猫有加菲猫，波斯猫一样，人也有各式各样的类型：有的人种高大，像巨人一样适合在寒冷的气候生活；有的特别矮，适合在洞穴群居；有的动作敏捷，反应迅速，适合在草原捕猎；有的性格温和，靠采集为生。但当时的人类有个共同点：全都还不会说话，也不会大规模合作，和猿类一样，三五成群地生活在地球上，和其他动物没有本质的区别。</p>
<p>大约在7万年前，有个母猿产下了两个女儿，一头变成了黑猩猩的祖先，演化出了猩猩分支，另一头也就演化成了现代人类的雏形，也就是智人分支。为啥称之为<strong>智人</strong>？因为智人有个特点，就是其大脑在不断进化，从最初600cm³的脑容量扩容到了现在1400cm³，而猩猩这个分支走的则是肌肉进化的路线。现在看来，肯定是发展智力有好处，利用知识来武装自己，比如制造出枪炮攻击与自卫，黑猩猩根本不是对手。可是在进化的初期，智人并没有任何优势可言。这个发展路线让智人的头越来越大，更不能生育，为了这一点，智人必须早产，以至于生下的婴儿没有任何生存能力，必须在外面成长几年才能有基本的活动能力。祸不单行，大脑还要抢走智人身体大部分能量，进而造成肌肉退化，运动能力减弱。</p>
<p>虽然黑猩猩要讲道理绝对讲不过智人，但它却能直接把智人像布娃娃一样扯个稀烂。在演化的游戏里，智人一开始便选择了困难模式。开始的时候，智人活得并不舒坦，处于食物链的中间，根本捕不到猎物。想吃肉了，就只能等老虎狮子捕食完，再等鬣狗把剩下的肉抹干净，走后才敢靠近猎物，用石头砸开骨头吃点骨髓。而平时智人的食物基本就是昆虫、野菜，处于饿不死的状态，整天还要担惊受怕，被其他动物欺负得死去活来的。终于有一天，智人偶然间发现了火的威力，这一发现让其咸鱼翻身，直接从食物链中间越到顶端。智人可以看心情选择时间地点放一把火，不但会出现一片平地，还能顺便烤熟一堆动物，这个能力瞬间又把其他动物欺负得不要不要的。火可以把食物烤熟，大大缩短了智人消化时间：黑猩猩吃一块生肉要消化5小时，智人吃熟肉1小时搞定。进食变快了，消化也快了，这种变化让肠道也开始缩短，节省了更多的能量来发展大脑，为变得越来越聪明打下了坚实基础。</p>
<p>然而，智人变得越来越聪明的同时，并没有变得越来越善良。他们在地球上四处乱逛，每到一个地方就开始大屠杀，进行种族清洗，比如马达加斯加这个岛屿上的大型动物就是因为智人的活动全部消失，澳大利亚的巨型动物的命运也是如此，所到之处，寸草不生。当然，即使学会了用火，能做出种族清洗这样的事情，也不是一件容易的事。除此之外，智人的大脑也进化出了语言能力，发明了一种比其他物种都复杂的交流方式，这个被称为<strong>认知革命</strong>。其实其他动物也可以交流，比如汪星人和喵星人，猩猩也会向同伴通风报信，但智人的语言复杂系数更高。比如在河边遇到一只狮子，猩猩只会简单地对同伴说河边有只狮子，而智人会对同伴进行描述，长得什么样，待会咱抄后路放把火把狮子吓走，然后把羚羊偷走。语言还有个好处就是可以用来八卦，比如智人吃饱后，小伙伴之间就开始相互说坏话，谁谁谁不靠谱上次捕猎临阵脱逃，谁谁谁勾搭别人老婆，然后就会产生群体内的舆论趋势，分辨出谁不靠谱，然后将其赶出队伍，慢慢的，智人形成了三观一致的相对稳定群体。</p>
<p>语言更大的好处是可以用它讲故事，虚构一些根本不存在的事物，把小伙伴们说信服了，然后跟着一块想象。这个能力可就牛X了，比如动物看见狮子本能反应只会跑，但智人当中会讲故事的人就会告诉小伙伴不要怕，狮子其实是我们的保护神，然后智人一下子对狮子的恐惧转变成了崇拜。后来又有人说，狮子保护神告诉我，隔壁部落有一群坏人，捕杀了我们好多食物，害的我们都没有饭吃，也没办法养育下一代。语言虚构的故事开始有了实质性的影响：智人组团去灭团。但是打仗和旅游可不一样，有可能就是有去无回。小伙伴们开始有点顾虑，万一灭团不成反被灭怎么办？这个时候又有人开始编故事了，说不用担心，狮子神已经都安排好了，死了之后就可以去它那里，从此过上丰衣足食的小康生活。小伙伴们一想：打一仗活下来可以分享战利品，死了也可以去神明那里过好日子，稳赚！于是就兴高采烈，屁颠屁颠地去打架了。语言的发明让社群有了组织协作能力，而且虚构故事的能力又极其灵活，可以组织大量陌生人产生大规模的协作，而此时其他物种还只会简单沟通，当遇到智人这群又团结又不怕死的家伙，自然逃脱不掉挨宰的命运。整个动物界从古至今，最重要也最具破坏性的力量，就是这群四处游荡、讲着故事的智人。</p>
<p>故事讲得多了，便形成了文化，文化团结了更多的智人生活在一起，部落变成了城市，城市组成了国家。可以说语言和文化是认知革命最重要的成就，自此之后，智人就能依据不断变化的需求迅速调整行为。这等于开启了一条采用“文化演化”的快速通道，而不再停留在“基因演化”这条总是堵车的道路上…</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>相对于学生时代学的历史，没有金戈铁马、成王败寇、没有歌功颂德。只是把一些看起来影响了进程的节点展示在你面前。让你开启上帝视角穿越到几万年前，虽然凡人在某些节点也许会想到换一个岔路会怎样？但是也只能看不能碰，即使未来也是：他要疯狂就疯狂，他想灭亡就灭亡，他要善良就善良。</p>
<p>看，上帝原来是个自由主义者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;renleijianshi.jpg&quot; alt=&quot;人类简史&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;从认知革命、农业革命到科学革命，
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人类简史" scheme="http://zerosoul.github.io/tags/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>读《清醒思考的艺术》</title>
    <link href="http://zerosoul.github.io/2016/03/12/think-again/"/>
    <id>http://zerosoul.github.io/2016/03/12/think-again/</id>
    <published>2016-03-12T00:17:59.000Z</published>
    <updated>2016-04-24T08:29:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="whereareyou.jpg" alt="think clearly"></p>
<blockquote>
<p>在群体里容易按照他人的想法生活，在孤独中容易按照自己的想法生活。但值得记住的只是那些在群体中保持独立的人。by 爱默生</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>人类一思考，上帝就发笑。</strong>我一直怀疑这句话存在断章取义，<strong>人类不思考，上帝就绝望</strong>是不是后一句？最近读到的一本书，肯定了自己的想法：《清醒思考的艺术》。</p>
<p>书的篇幅不长，阅读起来就像是看情景剧，每天两三集，有时上下班途中想想每个小故事对“思考”带来的启发，也是件可笑和沮丧的事。可笑在于我竟然在<strong>思考思考</strong>，沮丧在于这样做除了<strong>意识到自己一直在犯蠢</strong>之外，似乎没有任何积极的作用。</p>
<p>总得做点什么，于是我想到了一种笨办法：罗列书中所讲的思维偏误，尽可能用自己的话再解释一遍。咀嚼一遍，权当备忘。</p>
<h1 id="思维偏误"><a href="#思维偏误" class="headerlink" title="思维偏误"></a>思维偏误</h1><ul>
<li><p><strong>幸存偏误</strong><br>日常生活中，尤其各种媒体信息，更容易看到成功，看不到失败，这样会系统性地高估成功的希望。所以尽可能常去关注并了解下失败的案例，虽然伤感，但还是有好处的。</p>
</li>
<li><p><strong>游泳选手身材错觉</strong><br>游泳健将身材匀称、优美，并不是因为锻炼充分，实际情况正好相反：之所以成为游泳选手，是因为拥有这样的好身材。身躯是选择标准，而非运动的结果。所以在跨入游泳池之前，先照照镜子，诚实地对待自己。我们经常看到的由美女代言的化妆品广告，美丽是一种选择标准，而不是结果。所以在入手一份化妆品之前，想一想，是不是一瓶大宝就能解决问题？</p>
</li>
<li><p><strong>从众心理</strong><br>凭什么一种产品“销量最高”就应该更好呢？英国作家毛姆说过：就算有5000万人声称某件蠢事是对的，这件蠢事也不会因此成为聪明之举。</p>
</li>
<li><p><strong>纠缠于沉默成本</strong><br>有许多好理由支持你继续花费精力，但如果你只是因为舍不得已经投入的精力而决定继续下去，就不是一个好理由了。理性的决定意味着忽视已经投入的成本，唯一重要的是现在的形势以及你对未来的评估。</p>
</li>
<li><p><strong>确认偏误</strong><br>事实不会因为被忽视、被歪曲而消失。请写下你的信条–有关世界观、投资、婚姻、健康、成功等等，寻找反驳的证据。干掉自己最心爱的理论，这是一桩艰苦的工作。</p>
</li>
<li><p><strong>权威偏误</strong><br>出错是人类的通病，权威也不例外。但我们面对权威，常常会将独立思考调低一级。对权威的批判性越强，就越自由，就越相信自己有更多的能力。</p>
</li>
<li><p><strong>现成偏误</strong><br>我们依据现成的例子来想象世界，但外界现实中的某种东西不会因为我们更容易想到而出现得更频繁。我们的大脑是剧本式思维，而不是量化思维，喜欢新奇，华丽，壮观，吸引眼球的一切。所以，学点概率与统计吧，用数字做决策虽然有时候也会产生非预期的结果，但总比拍屁股决定靠谱多了。</p>
</li>
<li><p><strong>故事偏误</strong><br>瑞士作家马克斯.弗里施说过：我们尝试编故事，就像人们喜欢试穿衣服。用故事扭曲和简化现实，它们排斥掉不合适编进故事的一切。意义只是我们事后虚构的。经常对自己做这样的训练：将故事拆解开来，故事背后想隐藏什么？</p>
</li>
<li><p><strong>司机的知识</strong><br>“司机”寓指那些装得好像自己知道的人。它们会模仿别人表演，也可能拥有动听的声音或具有说服力的形象，但传播出的知识是空洞的，只是在高谈阔论挥霍着华丽词汇。真正有知识的人知道他们知道什么，也知道不知道什么。这类人一旦来到了“能力范围”之外，要么什么也不说，要不就说“我不知道”。</p>
</li>
<li><p><strong>控制错觉</strong><br>相信我们能够控制或影响某种我们客观上无法控制或影响的东西的倾向，就是控制错觉。所以，将有限的注意力集中于真正能影响的少量东西，其他的听之任之，不失为一种聪明之举。</p>
</li>
<li><p><strong>回归均值</strong><br>事情不会永远的好下去，也不会永远的坏下去。</p>
</li>
<li><p><strong>结果偏误</strong><br>结果差并不一定意味着当时所作的决定不对，反之亦然。分析过程，而非结果。这个决定是出于理性而做出的吗？如果是，那下回最好仍然这样做，哪怕上回的结果很糟糕。</p>
</li>
<li><p><strong>选择悖论</strong><br>过多的选择会降低生活质量。所以在存在好几个选项面前，仔细考虑你想要什么，写下你的标准，并务必遵守它，适合才是最好的。选择伴侣，亦是如此。</p>
</li>
<li><p><strong>团体迷思</strong><br>一群智慧的人做出愚蠢的决定，因为每个人都误以为自己的意见是正确的共识。所以，如果你是智囊团成员，无论何时，都要讲出你的看法–哪怕这看法不是很中听。如果你领导着一支团队，请指定某人唱反调，他将不是团队最受欢迎的人，但也许是最重要的人。</p>
</li>
<li><p><strong>忽视概率偏误</strong><br>我们对一件事的预期强度做出反应，而不是对它的概率，换个说法就是，我们缺少概率的直觉理解。</p>
</li>
<li><p><strong>稀少性谬误</strong><br>典型反应便是丧失清晰思考的能力，我们的一个物品被人夺走了，就会认为失去的物品更有价值，更有魅力。因此请你仅按照价格和作用判断一样东西，不要在乎它是否稀少，某个名人是否代言或用过。</p>
</li>
<li><p><strong>赌徒谬误</strong><br>人们相信命运具有一种平衡力量，但独立事件不存在平衡的力量。</p>
</li>
<li><p><strong>锚定效应</strong><br>谈判之前，先下定一个锚，从那里开始，结果往往不会偏离太远。</p>
</li>
<li><p><strong>规避损失</strong><br>恶比善更有影响力。我们对不利东西的反应要比对有利东西的反应更为敏感。</p>
</li>
<li><p><strong>社会性懈怠</strong><br>一同拉一根绳子的人越多，个人的贡献就越低。责任扩散，风险分摊。</p>
</li>
<li><p><strong>指数增长</strong><br>石器时代几乎没有人遇到过指数增长的例子，但今天不同。所以有关增长率时，不要相信你的感觉，计算器更有助于做出决策。</p>
</li>
<li><p><strong>错误的因果关系</strong><br>相互关系不等于因果关系。</p>
</li>
<li><p><strong>光环效应</strong><br>我们让某一个方面照花了眼睛，并由此推及全貌。所以为了接近真实，请排除醒目的特征，这样挖掘出来的东西并不总是漂亮的，但有时很有教益。</p>
</li>
<li><p><strong>行动偏误</strong><br>在过去，闪电式反应关乎生死存亡，思考则可能会致命。但我们今天的世界与过去不同，与行动相比，今天的世界奖励深刻的思考。这一转变让我们很难适应。所以，如果情况不明，请不要采取任何行动，直到能更好地分析形势。总之，克制自己，很有可能会带来额外的奖励。</p>
</li>
<li><p><strong>不作为偏误</strong><br>如果你不是答案的一部分，那就是问题的一部分。</p>
</li>
<li><p><strong>享乐适应症</strong><br>事业上迈进了一步的人在平均3个月后的幸福感又与先前一样了。我们工作，升迁，给自己购买更多更漂亮的东西，但我们不会变的更幸福。</p>
</li>
<li><p><strong>新手的运气</strong><br>假如开始时一切顺利，务必多加小心。请像一位科学家那样，武装自己，以防自欺欺人。测试你的看法，试着证明它们是错误的。</p>
</li>
<li><p><strong>双曲贴现</strong><br>一个决定离现在越近，我们的“情感利息”就越多，是否拥有延迟满足的能力是后来事业是否成功的一个可靠指示器。</p>
</li>
</ul>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>现实生活中，许多决定都是本能做出的，事后再虚构选择的理由，它让我们感觉自己是清醒地做出了决定。这种思维方式更像律师，精通于为一个已经确定的推论虚构出可能性最大的理由。</p>
<p>因此，思考本身是不纯粹的，是永远会犯错误的，所有人都一样，就连高智商的人也会再三触犯常见的思维偏误。但我们依然需要锻炼自己的思考，尽可能规避本能反应，因为今天的世界奖励深刻思考和自由行动。</p>
<p>清醒思考是奢侈的，回避思维偏误是很麻烦的，所以如果可能的损害较小，就无需绞尽脑汁，要允许错误的发生，这样才会活的更轻松。只要有一定把握应付生活，只要在关键时刻小心留神，决定是否完美，并不需要太在意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;whereareyou.jpg&quot; alt=&quot;think clearly&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在群体里容易按照他人的想法生活，在孤独中容易按照自己的想法生活。但值得记住的只是那些在群体中保持独立的人。by 爱默生&lt;/p&gt;
&lt;/blo
    
    </summary>
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="清醒思考的艺术" scheme="http://zerosoul.github.io/tags/%E6%B8%85%E9%86%92%E6%80%9D%E8%80%83%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    
      <category term="思维错误" scheme="http://zerosoul.github.io/tags/%E6%80%9D%E7%BB%B4%E9%94%99%E8%AF%AF/"/>
    
      <category term="认知偏差" scheme="http://zerosoul.github.io/tags/%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE/"/>
    
      <category term="社科" scheme="http://zerosoul.github.io/tags/%E7%A4%BE%E7%A7%91/"/>
    
  </entry>
  
  <entry>
    <title>jQuery最佳实践</title>
    <link href="http://zerosoul.github.io/2016/03/06/jquery-best-practice/"/>
    <id>http://zerosoul.github.io/2016/03/06/jquery-best-practice/</id>
    <published>2016-03-06T06:46:55.000Z</published>
    <updated>2016-07-06T10:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="jquery.jpg" alt="jquery"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用<a href="http://jquery.com/" target="_blank" rel="external">jQuery</a>已经有两年，其<a href="https://api.jquery.com/" target="_blank" rel="external">API</a>用起来非常的爽，甚至都成为了事实上的标准，以至于好多前端小白把jQuery等同于Javascript。虽然jQuery的普及度很高，但遵循最佳实践来写jQuery代码的却寥寥无几，下面就自己在工作的积累来写一些jQuery的最佳实践（也有从网络上搜集的）。</p>
<h1 id="加载jQuery"><a href="#加载jQuery" class="headerlink" title="加载jQuery"></a>加载jQuery</h1><ul>
<li><p>使用CDN加载，<a href="http://www.paulirish.com/2010/the-protocol-relative-url/" target="_blank" rel="external">去掉<code>http:</code>或者<code>https:</code></a>，同时做好本地fallback。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">window.jQuery || document.write('<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-2.1.4.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span>')</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>如果可能，请在底部加载jQuery外部文件</p>
</li>
<li>有关版本问题<ul>
<li>如果需要支持Internet Explorer 6/7/8，那就不要使用2.x</li>
<li>对于web app，请大胆使用最新版本的jQuery，当然，也可以选择<a href="http://zeptojs.com/" target="_blank" rel="external">zepto.js</a></li>
<li>不要使用<a href="http://blog.jquery.com/2014/07/03/dont-use-jquery-latest-js/" target="_blank" rel="external">jquery-last.js CDN</a></li>
</ul>
</li>
<li>检测浏览器特性，请用<a href="http://modernizr.com/" target="_blank" rel="external">Modernizr</a></li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li>所有的jQuery对象命名最好加个<code>$</code>前缀加以区分</li>
<li>缓存通过选择符获取的jQuery对象，以待复用：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $myDiv = $(<span class="string">"#myDiv"</span>);</div><div class="line">$myDiv.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><ul>
<li><p>对于一些较为复杂的DOM操作，可以先<code>.detach()</code>，原因<a href="http://learn.jquery.com/performance/detach-elements-before-work-with-them/" target="_blank" rel="external">参考此处</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list-container &gt; ul"</span>).detach();</div><div class="line"><span class="comment">//...在$myList上做了一系列复杂的操作后...</span></div><div class="line">$myList.appendTo(<span class="string">"#list-container"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>链式调用</p>
<ul>
<li><p>链式调用让代码更具可读性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#myDiv"</span>).addClass(<span class="string">"error"</span>).show();</div></pre></td></tr></table></figure>
</li>
<li><p>当调用过多时，注意合理加缩进，时刻维持代码可读性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#myLink"</span>)</div><div class="line">    .addClass(<span class="string">"bold"</span>)</div><div class="line">    .on(<span class="string">"click"</span>, myClickHandler)</div><div class="line">    .on(<span class="string">"mouseover"</span>, myMouseOverHandler)</div><div class="line">    .show();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><ul>
<li>尽可能使用ID选择器，因为jQuery源码中调用的是<code>document.getElementById()</code></li>
<li><p>当使用类选择器时，没必要再附加元素标签了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $products = $(<span class="string">"div.products"</span>); <span class="comment">// SLOW</span></div><div class="line"><span class="keyword">var</span> $products = $(<span class="string">".products"</span>); <span class="comment">// FAST</span></div></pre></td></tr></table></figure>
</li>
<li><p>对于像<em>Id-&gt;Child</em>这样的嵌套选择器，使用<code>.find()</code>性能更好些，因为id选择器不走Sizzle引擎，这能节约一些性能损耗。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD, 全部走的Sizzle选择器引擎</span></div><div class="line"><span class="keyword">var</span> $productIds = $(<span class="string">"#products div.id"</span>);</div><div class="line"></div><div class="line"><span class="comment">// GOOD, #products 走的是document.getElementById()，因此只有div.id走Sizzle 选择器引擎</span></div><div class="line"><span class="keyword">var</span> $productIds = $(<span class="string">"#products"</span>).find(<span class="string">"div.id"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>选择器父类越模糊越好，子类越详细越好。<a href="http://learn.jquery.com/performance/optimize-selectors/" target="_blank" rel="external">参考此处</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 未经优化的</span></div><div class="line">$(<span class="string">"div.data .gonzalez"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 优化后的</span></div><div class="line">$(<span class="string">".data td.gonzalez"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>给选择器以上下文</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SLOWER 遍历了整个文档的class</span></div><div class="line">$(<span class="string">'.class'</span>);</div><div class="line"></div><div class="line"><span class="comment">// FASTER 只在#class-container下遍历</span></div><div class="line">$(<span class="string">'.class'</span>, <span class="string">'#class-container'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>避免使用通配符<code>*</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'div.container &gt; *'</span>); <span class="comment">// BAD</span></div><div class="line">$(<span class="string">'div.container'</span>).children(); <span class="comment">// BETTER</span></div></pre></td></tr></table></figure>
</li>
<li><p>没有必要嵌套或组合使用ID选择器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#outer #inner'</span>); <span class="comment">// BAD</span></div><div class="line">$(<span class="string">'div#inner'</span>); <span class="comment">// BAD</span></div><div class="line">$(<span class="string">'.outer-container #inner'</span>); <span class="comment">// BAD</span></div><div class="line">$(<span class="string">'#inner'</span>); <span class="comment">// GOOD,  document.getElementById()搞定一切</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ul>
<li>每个页面有且仅有一个DOMReady事件，便于调试。</li>
<li><p>尽量不要使用匿名函数来用作事件处理，因为不利于调试，测试，维护和复用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD</span></div><div class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;); </div><div class="line"><span class="comment">// GOOD</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLinkClickHandler</span>(<span class="params"></span>)</span>&#123;...&#125;</div><div class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, myLinkClickHandler);</div></pre></td></tr></table></figure>
</li>
<li><p>避免HTML结构中声明并绑定事件处理函数，这非常不利于调试，也破坏了HTML紧做结构表现的职责。</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">&lt;!-- BAD --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"myLink"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"myEventHandler();"</span>&gt;</span>my link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, myEventHandler); <span class="comment">// GOOD</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用<a href="http://learn.jquery.com/events/event-delegation/" target="_blank" rel="external">事件代理机制</a>，一个明显的好处就是当有新子元素插入时，不用重新绑定事件，<a href="http://api.jquery.com/on/#direct-and-delegated-events" target="_blank" rel="external">参考此处</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#list a"</span>).on(<span class="string">"click"</span>, myClickHandler); <span class="comment">// BAD, 相当于给list下的所有a元素都绑定了click事件.</span></div><div class="line">$(<span class="string">"#list"</span>).on(<span class="string">"click"</span>, <span class="string">"a"</span>, myClickHandler); <span class="comment">//GOOD, 只给父元素list绑定了click事件.</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><ul>
<li><p>熟习<code>$.ajax()</code>，尽量不要用<code>.get()</code>,<code>.getJson()</code>这样的简洁方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ajax模板</span></div><div class="line"><span class="keyword">var</span> jqxhr = $.ajax(&#123;</div><div class="line">    url: url,</div><div class="line">    type: <span class="string">"POST"</span>, <span class="comment">// 默认GET</span></div><div class="line">    cache: <span class="literal">true</span>, <span class="comment">// 默认true, 但对于dataType为'script'或者'jsonp'，则为false</span></div><div class="line">    data: &#123;&#125;, <span class="comment">// 请求附带的参数</span></div><div class="line">    dataType: <span class="string">"json"</span>, </div><div class="line">    jsonp: <span class="string">"callback"</span>, <span class="comment">// 指定回调参数的名称</span></div><div class="line">    statusCode: &#123; <span class="comment">// 在此指定相应的响应状态的回调函数</span></div><div class="line">        <span class="number">404</span>: handler404,</div><div class="line">        <span class="number">500</span>: handler500</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">jqxhr.done(successHandler);</div><div class="line">jqxhr.fail(failureHandler);</div></pre></td></tr></table></figure>
</li>
<li><p>请求地址最好用<em>无协议的URL</em>，即去除<code>http:/https:</code></p>
</li>
<li><p>使用<code>data</code>对象传送数据，而非附加在URL里</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可读性不好...</span></div><div class="line">$.ajax(&#123;</div><div class="line">    url: <span class="string">"something.php?param1=test1&amp;param2=test2"</span>,</div><div class="line">    ....</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"><span class="comment">// 更具可读性...</span></div><div class="line">$.ajax(&#123;</div><div class="line">    url: <span class="string">"something.php"</span>,</div><div class="line">    data: &#123; param1: test1, param2: test2 &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>使用Promise风格，<a href="http://www.htmlgoodies.com/beyond/javascript/making-promises-with-jquery-deferred.html" target="_blank" rel="external">例子</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123; ... &#125;).then(successHandler, failureHandler);</div><div class="line"> </div><div class="line"><span class="comment">// OR</span></div><div class="line"><span class="keyword">var</span> jqxhr = $.ajax(&#123; ... &#125;);</div><div class="line">jqxhr.done(successHandler);</div><div class="line">jqxhr.fail(failureHandler);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><ul>
<li>不要滥用动画效果，或者干脆不用，直到PM有切实需求。</li>
<li>如果用动画，优先使用像<code>show/hide</code>和<code>slideUp/slideDown</code>这样的简单API</li>
</ul>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><ul>
<li>优先考虑有良好文档，有测试用例，有社区支持的插件</li>
<li>使用插件前不要忘记检测与你正在使用的jQuery版本是否冲突</li>
<li>任何可复用的组件都应该插件化，这里有个<a href="https://john-dugan.com/jquery-plugin-boilerplate-explained/" target="_blank" rel="external">插件模板</a>。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li><p>使用对象字面量设置特性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD</span></div><div class="line">$myLink.attr(<span class="string">"href"</span>, <span class="string">"#"</span>).attr(<span class="string">"title"</span>, <span class="string">"my link"</span>).attr(<span class="string">"rel"</span>, <span class="string">"external"</span>); <span class="comment">// </span></div><div class="line"><span class="comment">// GOOD</span></div><div class="line">$myLink.attr(&#123;</div><div class="line">    href: <span class="string">"#"</span>,</div><div class="line">    title: <span class="string">"my link"</span>,</div><div class="line">    rel: <span class="string">"external"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>避免使用jQuery添加CSS</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD</span></div><div class="line">$(<span class="string">"#mydiv"</span>).css(&#123;<span class="string">'color'</span>:red, <span class="string">'font-weight'</span>:<span class="string">'bold'</span>&#125;); <span class="comment">// BAD</span></div></pre></td></tr></table></figure>
<p>  定义好CSS rule</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.error</span> &#123; <span class="attribute">color</span>: red; <span class="attribute">font-weight</span>: bold; &#125; <span class="comment">/* GOOD */</span></div></pre></td></tr></table></figure>
<p>  然后通过jQuery添加class</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#mydiv"</span>).addClass(<span class="string">"error"</span>); <span class="comment">// GOOD</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="优秀资源"><a href="#优秀资源" class="headerlink" title="优秀资源"></a>优秀资源</h1><ul>
<li><a href="http://api.jquery.com/" target="_blank" rel="external">jQuery API Docs</a></li>
<li><a href="http://learn.jquery.com/" target="_blank" rel="external">jQuery Learn</a></li>
<li><a href="http://learn.jquery.com/performance/" target="_blank" rel="external">jQuery Performance</a></li>
<li><a href="https://john-dugan.com/jquery-plugin-boilerplate-explained/" target="_blank" rel="external">A jQuery Plugin Boilerplate Explained</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;jquery.jpg&quot; alt=&quot;jquery&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用&lt;a href=&quot;http://jquery.co
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jquery" scheme="http://zerosoul.github.io/tags/jquery/"/>
    
      <category term="最佳实践" scheme="http://zerosoul.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题的思考</title>
    <link href="http://zerosoul.github.io/2016/03/06/how-to-interview/"/>
    <id>http://zerosoul.github.io/2016/03/06/how-to-interview/</id>
    <published>2016-03-06T02:43:44.000Z</published>
    <updated>2016-05-24T08:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="areyouok.png" alt="are you ready"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司在招前端，一件说大不大，说小不小的事情。第一次当起了面试官，不敢掉以轻心，准备工作要做足，毕竟要招进来的人是经常朝夕相处的同事，靠谱些为好。经过几天的实践与反思，总结了一套适合自己的面试问题，希望对一些人有所启发。每个题目都没有标准答案，注重的是答题的思路以及对问题本身的拓展，有些给出了<strong>参考链接</strong>，都是我曾经读过的文章，恩，如果英语不过关，祝好运。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><ul>
<li><p><strong>昨天或者最近这一周，学了些什么？</strong><br>前端这个工种是依托互联网的繁荣快速发展起来的，因而也就促使着前端不断革新技术来满足日新月异的互联网。学习不是为了跟风，什么新学什么，而是为了完善和更新自己的技能树，保持核心竞争力。如果能从这个问题的回答看出你有阅读，学习，实践的习惯，那就更好了。</p>
</li>
<li><p><strong>如果今年想掌握一门新技术，会是什么？为什么选择它？</strong><br>如果说上面那个问题是战术问题，那么这个应该就是战略问题。无论想横向发展还是纵向发展，都逃不脱一个<strong>成长</strong>的话题，透过这个问题，可以了解下应聘者的技术视野，同时也是其成长的方向与潜力。</p>
</li>
<li><p><strong>最近有没有遇到些问题？你是如何解决的？</strong><br>这个问题比较开放，即使遇到的不是技术问题，也可以回答，比如，遇到的问题是马桶堵了，也可以说出来。主要是了解下应聘者解决问题的思路。</p>
</li>
<li><p><strong>谈谈你的开发流程与环境</strong><br>有多热爱开发，就得有多热心于开发环境的打磨，因为上班的绝大部分时间都是沉浸在这个环境下，舒适度很重要。</p>
</li>
<li><p><strong>有没有在线的得意之作，为了完成这个作品，用到了哪些工具，你贡献了哪些功能或者想法，能谈谈吗？</strong><br>有些前端业余会做一些小项目，实践新知的同时涨涨姿势。这些小作品往往能给面试锦上添花。</p>
</li>
<li><p><strong>有写博客吗？</strong><br>写博客是一种输出，也是一种沉淀，即便不怎么写技术类文章，能坚持写的，是靠谱特征之一。</p>
</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>HTML是骨架，是基础。语义化标签，SEO，兼容性，加载和渲染顺序与性能等等，在写HTML代码时都需要考虑进来。</p>
<ul>
<li><p><strong>大概写一下你常用的HTML骨架（PC&amp;Mobile）</strong></p>
</li>
<li><p><strong>Quirks Mode（怪异模式）和Standards Mode（标准模式）的异同点</strong><br><a href="https://developer.mozilla.org/en-US/docs/Quirks_Mode_and_Standards_Mode" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>什么是Flash of Unstyled Content（FOUC），如何避免？</strong><br><a href="http://www.techrepublic.com/blog/web-designer/how-to-prevent-flash-of-unstyled-content-on-your-websites/" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>尽可能多地列举出HTML5新标签</strong><br>基础问题，如果不能列举出三个以上，下面那个问题也没必要问了。</p>
</li>
<li><p><strong>HTML5的新特性里面，你最喜欢哪个？为什么？</strong><br>开放性问题，目的在于了解对HTML5的认知与实践。</p>
</li>
<li><p><strong>cookie,localStorage和sessionStorage 异同点</strong><br><a href="http://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookies" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>解释下CORS，怎样使用</strong><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>script标签 <code>async</code> 与<code>defer</code>两个特性的异同点</strong><br><a href="http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>CSS放在head标签头部，js放在body标签底部，有啥优点？可不可以不这样？</strong><br><a href="http://stackoverflow.com/a/25275805" target="_blank" rel="external">参考链接</a></p>
</li>
</ul>
<ul>
<li><strong><code>event.PreventDefault</code>，<code>event.stopPropagation</code>与<code>return false</code>异同点</strong><br><a href="http://stackoverflow.com/questions/1357118/event-preventdefault-vs-return-false" target="_blank" rel="external">参考链接</a></li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS是我的薄弱项，只考察基础，但是有这些基础我认为也就够了。任重道远，共勉。</p>
<ul>
<li><p><strong>尽可能多地列举display属性值，追问：<code>inline</code>和<code>inline-block</code>的区别</strong></p>
</li>
<li><p><strong>尽可能多地列举position属性值，追问：<code>absolute</code>是怎么工作的</strong></p>
</li>
<li><p><strong>为什么会产生浮动，清除浮动的技巧</strong><br><a href="http://www.sitepoint.com/clearing-floats-overview-different-clearfix-methods/" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>描述下你对盒模型的理解，通过CSS怎么告知浏览器使用不同的盒模型</strong><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>解释下Block Formatting Content (BFC)，它是如何工作的</strong><br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>使用过哪些CSS框架？有没有试过更改或者改进它们？</strong><br>开放性问题，目测一般会回答Bootstrap。</p>
</li>
</ul>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>公司项目中写交互的场景比较多，所以这一块是重点考察的，虽然平时都使用jQuery，但有javascript的基础更为重要。</p>
<ul>
<li><p><strong><code>===</code>与<code>==</code>异同点</strong><br>基础问题，这个如果表现出不知所措，就没必要往下进行了。</p>
</li>
<li><p><strong>实现下面的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">duplicate([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);<span class="comment">//[1,2,3,1,2,3]</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>描述下document.write()使用场景</strong></p>
</li>
<li><p><strong><code>onload</code>和 <code>$(document).ready</code>的区别</strong><br><a href="http://stackoverflow.com/questions/3698200/window-onload-vs-document-ready" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>immediately-invoked function expression（IIFE）的工作原理</strong><br><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>谈一下你对javascript中<code>this</code>的理解</strong><br><a href="http://javascriptissexy.com/understand-javascripts-this-with-clarity-and-master-it/" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>事件代理(Event Delegation)</strong><br><a href="https://davidwalsh.name/event-delegate" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>闭包是什么？举例它在实际工作的应用</strong><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>说出下面代码Person函数使用的区别</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> person1=Person();</div><div class="line"><span class="keyword">var</span> person2=<span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
</li>
<li><p><strong><code>call</code>和<code>apply</code>的异同点</strong><br><a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>你是如何理解<strong>hoisting</strong>的</strong><br><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>尽可能详细地解释下AJAX，请写出创建并发送一个AJAX请求的过程。</strong><br><a href="https://developer.mozilla.org/en-US/docs/AJAX" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>解释下JSONP，为什么说它不是真正的AJAX?</strong><br><a href="http://stackoverflow.com/questions/7115940/difference-between-ajax-restful-rest-json-and-jsonp" target="_blank" rel="external">参考链接</a></p>
</li>
<li><p><strong>当写<code>onscroll</code>事件的回调函数时，你能想到的最佳实践是什么？</strong><br><a href="https://dannyvankooten.com/delay-scroll-handlers-javascript/" target="_blank" rel="external">参考链接</a></p>
</li>
</ul>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>公司项目中，用到了jQuery，所以有必要考察一下这方面的基础，其实如果前面问题回答的足够出色，这一块可以忽略，因为相信有了前面的基础，jQuery上手会很快。</p>
<ul>
<li><p><strong>jQuery是个框架还是类库，为什么使用？</strong></p>
</li>
<li><p><strong>如何使用jQuery获取元素的属性</strong></p>
</li>
<li><p><strong>如何使用jQuery同时选取多个元素</strong></p>
</li>
<li><p><strong>单击下面P标签，其背景色变为黑色，再单击回复原来颜色，使用jQuery实现</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test_tag"</span>&gt;</span>点我变色，再点我恢复<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>大概写出jQuery下AJAX使用场景</strong></p>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul>
<li><p><strong>为什么说在多个域名下存放静态资源会好一些？</strong></p>
</li>
<li><p><strong>浏览器地址栏输入URL敲回车那一刻起到页面完全呈现出，尽可能详细描述出中间发生了什么。</strong></p>
</li>
<li><p><strong>长轮询，Websocket，SSE</strong></p>
</li>
<li><p><strong>HTTP Method 有哪些，尽可能多地列举</strong></p>
</li>
</ul>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>以上是我经过思考与总结的一套前端技术面试题，大部分都能在网上找到答案。当然，面试时不会都问到，随机选七八个问题就差不多了。前端远不止这些，有很多比较成熟的技术并没有提及，比如NODE.js，比如Angular.js，再比如React.js，但招聘的目的不是为了炫技，更不是要故意为难应聘者，而是筛选出适合公司发展的人员。可以参考，但不要照搬，靠谱与否，自己衡量。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions" target="_blank" rel="external">Front-end Job Interview Questions</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;areyouok.png&quot; alt=&quot;are you ready&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近公司在招前端，一件说大不大，说小
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://zerosoul.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://zerosoul.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试题" scheme="http://zerosoul.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>再读雅虎14条军规</title>
    <link href="http://zerosoul.github.io/2016/01/30/high-performance-web-sites-note/"/>
    <id>http://zerosoul.github.io/2016/01/30/high-performance-web-sites-note/</id>
    <published>2016-01-30T04:10:05.000Z</published>
    <updated>2016-01-30T04:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章是<a href="http://book.douban.com/subject/3132277/" target="_blank" rel="external">《高性能网站建设指南——前端工程师技能精髓》</a>的读书笔记，即，<a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">雅虎14条军规</a>扩展版。个人认为书名副标题取名并不精确，<strong>前端工程师优化技能精髓</strong>似乎更适合，本文粗线条地记录了我觉得应该记录下来的知识点。个人备忘录，不具备连贯性，看不懂就对了。</p>
<h1 id="通识"><a href="#通识" class="headerlink" title="通识"></a>通识</h1><h2 id="性能黄金法则"><a href="#性能黄金法则" class="headerlink" title="性能黄金法则"></a>性能黄金法则</h2><p>最终用户只有10%~20%的响应时间花在了下载HTML文档上，其余的80%~90%时间花在了下载页面中的所有组件上。<br><strong>注：该统计出于大概十年前，现在比例应该有所变化，但还是有很大的优化空间</strong></p>
<h2 id="HTTP备忘点"><a href="#HTTP备忘点" class="headerlink" title="HTTP备忘点"></a>HTTP备忘点</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>Request：<code>Accept-Encoding: gzip,deflate</code><br>Response:<code>Content-Encoding: gzip</code></p>
<h3 id="条件Get请求"><a href="#条件Get请求" class="headerlink" title="条件Get请求"></a>条件Get请求</h3><p>Request:<code>If-Modified-Since: Wed, 22 Feb 2016 09:23:44 GMT</code><br>Response:<code>Last-Modified: Wed, 22 Feb 2016 09:23:44 GMT</code></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Response:<code>Expires: Wed, 22 Feb 2016 09:23:44 GMT</code></p>
<h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h3><p>Request:<code>Connection: keep-alive</code><br>Response:<code>Connection: keep-alive</code></p>
<h1 id="14军规"><a href="#14军规" class="headerlink" title="14军规"></a><a href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="external">14军规</a></h1><h2 id="减少HTTP请求-Make-Fewer-HTTP-Request"><a href="#减少HTTP请求-Make-Fewer-HTTP-Request" class="headerlink" title="减少HTTP请求 Make Fewer HTTP Request"></a>减少HTTP请求 <em>Make Fewer HTTP Request</em></h2><ul>
<li>图片地图</li>
<li>CSS Sprites<br>很多人认为合并后的图片会比分离的图片综合要大，因为合并后包含附加的空白区域。实际上恰恰相反，因为它降低了图片自身的开销（颜色表，格式信息，等等）</li>
<li>内联图片<br><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></li>
<li>合并脚本和样式表</li>
</ul>
<h2 id="使用内容发布网络（CDN）"><a href="#使用内容发布网络（CDN）" class="headerlink" title="使用内容发布网络（CDN）"></a>使用内容发布网络（CDN）</h2><ul>
<li>缺点：修改HTTP响应头必须通过第三方完成。</li>
</ul>
<h2 id="添加Expires头"><a href="#添加Expires头" class="headerlink" title="添加Expires头"></a>添加Expires头</h2><ul>
<li>可以同时制定两个响应头：Expires和Cache-Control的max-age。如果两者同时出现，HTTP规范规定max-age指令将重写Expires头，例如：<br><code>Expires: Mon,15 Apr 2024 20:00:00 GMT</code><br><code>Cache-Control: max-age=312</code></li>
</ul>
<h2 id="开启Gzip压缩"><a href="#开启Gzip压缩" class="headerlink" title="开启Gzip压缩"></a>开启Gzip压缩</h2><ul>
<li>注意点：代理缓存</li>
<li>在Web服务器相应中添加<code>Vary</code>头，这样就可以告诉代理根据一个或多个请求头来改变缓存的响应。<br><code>Vary: Accept-Encoding</code><br>代理缓存响应的多个版本，当有gzip头的请求时，响应压缩过的，反之是未经压缩的。</li>
<li>禁用缓存：<code>Vary: *</code>或<code>Cache-Control: private</code></li>
</ul>
<h2 id="将样式表放在顶部"><a href="#将样式表放在顶部" class="headerlink" title="将样式表放在顶部"></a>将样式表放在顶部</h2><ul>
<li>样式表放在底部对加载页面所需的实际时间并没有太大影响，但会导致浏览器阻止内容逐步呈现，这让用户感性上觉得页面加载更慢。</li>
<li>无样式内容的闪烁FOUC（Flash of Unstyled Content）是浏览器行为，在样式表正确地下载并解析后，已经呈现的文字和图片要用新的样式重绘了。浏览器可以延迟呈现，知道所有样式表下载完毕，这导致了白屏，反之可以逐步呈现，但要承担闪烁的风险，这里没有完美的选择。</li>
</ul>
<h2 id="将脚本放在底部"><a href="#将脚本放在底部" class="headerlink" title="将脚本放在底部"></a>将脚本放在底部</h2><ul>
<li>放在顶部的影响：<ul>
<li>会阻塞对其后面内容的呈现</li>
<li>会阻塞对其后面资源的下载</li>
</ul>
</li>
<li><code>defer</code>属性表明脚本不包含<code>document.write</code>，浏览器有这个线索可以继续呈现。</li>
</ul>
<h2 id="避免CSS表达式"><a href="#避免CSS表达式" class="headerlink" title="避免CSS表达式"></a>避免CSS表达式</h2><ul>
<li>谁会想到用户点击了一个文本框会导致IE锁死呢。</li>
<li>避免方式：创建一次性表达式和使用事件处理器取代CSS表达式  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">p&#123;</div><div class="line">    background: expression( altBg(this));</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;script&gt;</div><div class="line">function altBg(ele)&#123;</div><div class="line">    ele.style.backgroundColor=(new Date()).getHours()%2 ? &quot;#f08&quot;:&quot;B98&quot;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用外部javascript和css"><a href="#使用外部javascript和css" class="headerlink" title="使用外部javascript和css"></a>使用外部javascript和css</h2><ul>
<li>页面浏览量越少，内联论据越强势，反之外置论据越强势。</li>
</ul>
<h2 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h2><ul>
<li>将静态资源放在独立域名下较好，但不要超过四个，在减少DNS查找和允许并行下载之间做出权衡。</li>
</ul>
<h2 id="精简javascript和CSS"><a href="#精简javascript和CSS" class="headerlink" title="精简javascript和CSS"></a>精简javascript和CSS</h2><ul>
<li>gzip压缩产生的影响更大，但精简能够进一步减小文件大小。</li>
</ul>
<h2 id="避免重定向"><a href="#避免重定向" class="headerlink" title="避免重定向"></a>避免重定向</h2><ul>
<li>当服务器向浏览器返回一个重定向时，是指一个范围在3XX的状态码，表示用户代理必须执行进一步操作才能完成请求。<ul>
<li>300 Multiple Choices</li>
<li>302 Moved Permancently</li>
<li>302 Moved Temporarily</li>
<li>303 See other</li>
<li>304 Not Modified (并非重定向，用来响应条件GET请求)</li>
<li>305 Use Proxy</li>
<li>306 不再使用</li>
<li>307 Temporary Redirect</li>
</ul>
</li>
<li><code>301</code>和<code>302</code>是使用最多的,<code>303</code>和<code>307</code>是HTTP 1.1添加的，用来澄清对302的使用，但现实情况是几乎没人采用。</li>
<li>还有其他方式：<ul>
<li>HTML META :<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=http://google.com&quot;&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="删除重复脚本"><a href="#删除重复脚本" class="headerlink" title="删除重复脚本"></a>删除重复脚本</h2><ul>
<li>确保脚本只被包含一次，否则会带来性能损伤。</li>
</ul>
<h2 id="配置ETag"><a href="#配置ETag" class="headerlink" title="配置ETag"></a>配置ETag</h2><ul>
<li>ETag是唯一标识一个静态资源特定版本的字符串。</li>
<li>If-None-Match比If-Modified-Since具有更高的优先级</li>
<li>ETag可能会引发性能问题，这时候完全可以移除ETag</li>
</ul>
<h2 id="使AJAX可缓存"><a href="#使AJAX可缓存" class="headerlink" title="使AJAX可缓存"></a>使AJAX可缓存</h2><ul>
<li>当数据被认为是私有的时候，大多会使用<code>Cache-Control: no-store</code>。这样的响应根本不会被写入磁盘。</li>
<li>确保AJAX请求遵守性能优化原则，尤其应具有长久的Expires头</li>
</ul>
<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>虽然知识点比较基础，但并不过时，读后我立即在自己博客上实践了下：</p>
<ul>
<li>图片使用七牛CDN，感谢<a href="https://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="external">hexo-qiniu-sync</a>，访问速度明显加快。</li>
<li>删掉和替换掉了一些鸡肋功能，比如<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT主题</a>自带的浏览图片插件，换成了自己的简洁实现。</li>
<li>本来想搞一下HTTP配置，由于本站HOST在Github上，无从下手，好在Github在HTTP优化原则上已经做得很好了，省心省力。</li>
</ul>
<p>除了HTML/CSS/JavaScript(这三样已经够折腾的了)，一个优秀的前端工程师还应该具备什么样的技能呢？从这本书可以得到点启发：</p>
<ul>
<li>理解HTTP协议[<a href="http://book.douban.com/subject/10746113/" target="_blank" rel="external">《HTTP权威指南》</a>足矣]</li>
<li>了解浏览器工作原理及不同浏览器间的差异</li>
<li>掌握服务器端编程[可以从Node入手]</li>
<li>了解网络环境配置[可以学学Nginx]</li>
</ul>
<p><img src="hp.jpg" alt="high performance"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这篇文章是&lt;a href=&quot;http://book.douban.com/subject/3132277/&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="读书笔记" scheme="http://zerosoul.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="前端" scheme="http://zerosoul.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="最佳实践" scheme="http://zerosoul.github.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="优化" scheme="http://zerosoul.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>会议&amp;活动拍摄备忘录</title>
    <link href="http://zerosoul.github.io/2016/01/25/shoot-the-meeting/"/>
    <id>http://zerosoul.github.io/2016/01/25/shoot-the-meeting/</id>
    <published>2016-01-25T14:12:16.000Z</published>
    <updated>2016-01-27T13:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从有单反开始，已经多次跟拍公司活动和会议。依旧小白，经验为数不多，教训却一大堆。最近一次的年会拍摄，环境比较复杂，幸好有位经验丰富的姐姐，我与她一起工作，学了不少实战经验，这篇文章记录了我觉得应该注意的地方，以备后忘。</p>
<h1 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h1><ul>
<li>相机：确认没故障，如果有条件，可以有个备用相机；</li>
<li>电池：最好两块以上的电池，并带好充电器，以免电池原因耽误工作。我有过两次因为相机没电不得不终止拍摄任务的时候，给人一种不专业的感觉。</li>
<li>镜头：以24-70焦段作为主要镜头。原因很简单，这个焦段广角变形不严重而且包含人像拍摄最佳的50焦段。广角镜头边缘变形很严重，谁也不想自己的面部在照片里变形，所以最好不用。如果可能，带上70-200或100-300的镜头，长焦镜头拍一些领导讲话的特写十分方便，如果可以在会场里走来走去甚至走上主席台，那这个长焦也不用带了；</li>
<li>储存卡：最好带上一个备用储存卡，尽管现在的记录介质储存容量可以达到2千张4兆图片的容量，但是仍然要带上一个备用的。这种事不怕一万，就怕万一，反正不重。</li>
<li>脚架：三脚架在这种需要不停走动的场合一般用不上，但是最好带上独脚架，有备无患，反正也不占地。如需拍摄合影，那就别怕麻烦了。</li>
<li>闪光灯：带上一只机外闪光灯和<strong>两套电池</strong>（备用电池真的很有必要，意外总是能在你想象不到的时候发生）。一般相机自带的闪灯指数较小而且只能直闪，局限较大，容易过度曝光。</li>
<li>工具：镜头纸、小皮枪、刷子等清洁用品。</li>
<li>包：准备一个能把这些东西都放进去的摄影包。</li>
</ul>
<h1 id="相机的使用"><a href="#相机的使用" class="headerlink" title="相机的使用"></a>相机的使用</h1><ul>
<li>iso：如果可能，在室内尽量提高iso。活动拍摄曝光速度的提高能更好的提高图片的清晰度。至于噪点，如果受众不专业，那么根本不会在乎；不过即使碰到了十分专业的看客，那也能理解你的做法。我用过三部相机，都是佳能，以我的感受，5Dmark2以上的相机，iso开到2000,70D的相机可开1000，噪点都在可以忍受的范围之内。如果是600D一类的入门相机，iso800问题也不大[我的就是600D，噗~]。</li>
<li>光圈：就算镜头很棒，也尽量不要把光圈开的很大。原因有二，首先尽量不使用镜头的光圈值两端，画质会有些轻微的影响；最重要的是大光圈（如2.8）的对焦平面很薄，如果你拍的人物前后相差10厘米，就会出现一实一虚的情况。所以最好在4.5以上。</li>
<li>闪光灯：屋顶不很高的话，最大值四米左右，采用反射闪光并利用<a href="http://toutiao.com/a3676271723/" target="_blank" rel="external">眼神光板</a>。反射闪光的好处是在提高拍摄主题亮度的同时，还可以适当提高拍摄环境的亮度，且被摄主题四周，尤其是后面，不会出现十分明显的黑影。眼神光板可以增加被摄主体的亮度，调整眼神光板的反光量可通过调整闪光灯的输出功率（使亮度更高或更低）、改变闪光灯焦段或直接使用柔光板（增加闪光角度）</li>
</ul>
<p>在必须使用闪光灯而且需要交代环境的情况下，一般应保证快门速度最少80、光圈不低于4.5（保证足够的对焦平面）、并相应调整iso值后测出曝光准确值。在使用闪光灯后通过调整闪光灯的输出量，找出满意曝光值。这样可以更好表现被摄主体所处的环境。</p>
<h1 id="现场拍摄"><a href="#现场拍摄" class="headerlink" title="现场拍摄"></a>现场拍摄</h1><ol>
<li>空镜头拍摄：到场后一定不要忘记拍摄会场以及会场各区域的空镜。包括会场（曝光要以会场主体，如舞台等数值为主）、大门口签到处、一些较大的会议活动还会在会场外布置横幅、氢气球一类的的布置，也不能忘掉，还有就是特别的细节拍摄（会场装饰物），比如：准备发奖用的奖杯、奖状特写等等。</li>
<li>主要人物会前拍摄：活动前要和承办负责人沟通，确定拍摄人物重点（包括主要领导以及受邀来宾等），并且记录主要领导或重要来宾交谈的场面，包括寒暄和互赠名片，尽量能够结合背景的陈设，交代会议场所和环境。</li>
<li>过程拍摄：</li>
</ol>
<ul>
<li>领导讲话：如果条件允许，尽量抵近拍摄。这样可以将主席台的横幅、投影等反映会议内容的信息拍摄在画面当中。拍摄时机需要摄影者掌握，一般在讲话者抬头与参会者眼神交流活有手势时按下快门，这样可使讲话者显得更加生动。也有的领导自始至终不抬头交流，这样的拍摄一般在讲话开始时活结束时会出现抬头的机会。但是为了保险起见，低头的时候一定要拍上几张以免内容缺失。拍摄角度一般要与讲话者同高，尽量不使用仰角或俯角拍摄，并和讲话者保持45度左右的角度；</li>
<li>会场：主席台拍摄一定要有全景和单人的特写。由于主席台背景一般色调较暗，拍摄尽量使用人脸曝光值测光数据，注意不要让麦克风、水杯等挡住面部，如果有必要可以有一定的角度。另外会场内前排就坐的一般为比较重要的参会者，所以需要从左右两个方向对会场进行拍摄。最后还要对会场全景拍摄，拍摄位置一般为后场后左、中、右三个位置各拍一张，曝光值同样应该以主席台测光数值为准。</li>
<li>互动：一定要注意主要领导和重要与会者的活动并兼顾其他与会者。拍摄尽量做到人物和能够表现活动的主题的背景相结合。当参与活动的人员走动时，应尽量走到前面拍摄，而不是从后面跟随。还要提醒一下，照片的曝光时间，宁欠勿过[这点我做的很不好，往往造成了在光圈模式下照虚了的结果]。</li>
</ul>
<h1 id="再说两句"><a href="#再说两句" class="headerlink" title="再说两句"></a>再说两句</h1><p>以上所讲大部分并非我的原创，有感于年会专业摄影姐姐的谆谆教导，最近这两天也看了一些相关文章，才汇集出此篇文章。会议或活动摄影类似纪实摄影，就算注意事项熟记于心，现场千奇百怪的突发现象也会让你不知所措，这时候才是真正的考验。</p>
<p>有人问过我，为毛明明可以参与热闹，却干起了累死累活的摄影记录者，最后的结果往往也是吃力不讨好。个中原因我也说不清，最初也是有私心，想借此挡酒，后来觉得这里面有学问，既然做了，就尽力做好。简言之：<strong>始于私心，归于热爱</strong>。</p>
<p>至此，现场摄影告一段落，需要学的还有很多，不仅仅是技术，更多的是感觉。最后，附上几张我拍过的现场照：</p>
<p>注：我挑选的是<strong>个人认为可公开的图片</strong>，所以如果有冒犯之处，请与我<a href="http://zerosoul.github.io/about/#非诚勿扰">联系</a>，删除并道歉。</p>
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_1.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_2.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_3.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_4.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_5.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_6.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_7.jpg">
<img src="http://7xo6wq.com1.z0.glb.clouddn.com/static/images/live_8.jpg">
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从有单反开始，已经多次跟拍公司活动和会议。依旧小白，经验为数不多，教训却一大堆。最近一次的年会拍摄，环境比较复杂，幸好有位经验丰富的姐姐，我
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="摄影" scheme="http://zerosoul.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
      <category term="总结" scheme="http://zerosoul.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>隐藏email地址的小技巧</title>
    <link href="http://zerosoul.github.io/2016/01/23/another-email-hiding-technique/"/>
    <id>http://zerosoul.github.io/2016/01/23/another-email-hiding-technique/</id>
    <published>2016-01-23T03:59:15.000Z</published>
    <updated>2016-01-23T04:57:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="spambot.jpg" alt="spam bot"></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我们经常会受到垃圾邮件的骚扰，究其原因，其中主要就是平时email地址赤裸裸地暴露在网页中，被垃圾邮件程序（<a href="https://en.wikipedia.org/wiki/Spambot" target="_blank" rel="external">spambot</a>）探测到，进而向你的邮箱发送大量的营销信息，恶心到吐。</p>
<h1 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h1><p>上面提到的问题解决办法有许多，这里列举几个常用的：</p>
<ul>
<li>使用图片（使用谷歌邮箱的同学应该有所体会）</li>
<li>使用javascript输出（爬虫只探测静态HTML）</li>
<li>使用AT, DOT,代替<code>@</code>,<code>.</code>（好像现在一些爬虫也能识别了）</li>
<li>简单加密，比如：foo@REMOVETHISbar.baz，真正的email是去掉 <strong>REMOVETHIS</strong>之后的（也可以更形象点foo@<del>REMOVETHIS</del>bar.baz）</li>
<li>使用CSS中的伪类<code>:after</code> </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p:after &#123; content: "foo\40bar.baz"; &#125;</div><div class="line">&lt;p&gt;email me: &lt;/p&gt;</div><div class="line"></div><div class="line">/* \40 是Unicode字符 '@'*/</div><div class="line">email me: foo@bar.baz</div></pre></td></tr></table></figure>
<ul>
<li>使用flash</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;object type=&quot;application/x-shockwave-flash&quot; data=&quot;media/flash/articles/email.swf&quot;</div><div class="line">    codebase=&quot;http://fpdownload.macromedia.com</div><div class="line">    /pub/shockwave/cabs/flash/swflash.cab</div><div class="line">    #version=6,0,0,0&quot;&gt;</div><div class="line">    &lt;param name=&quot;movie&quot; value=&quot;media/email.swf&quot;&gt;</div><div class="line">&lt;/object&gt;</div></pre></td></tr></table></figure>
<p><ul></ul></p>
<h1 id="最优解"><a href="#最优解" class="headerlink" title="最优解"></a>最优解</h1><blockquote>
<p>世界上本来没有最优解，用的人觉得很爽，于是就有了。     —詹姆斯.杨二</p>
</blockquote>
<p>我个人比较喜欢最小化成本解决问题，所以除了上述几种方式，我更倾向于下面这种：<br>不知道你有没有发现，Unicode中有个和 <strong>@</strong>符号很像的字符：<code>0xFF20</code>，除此之外，还有个和 <strong>.</strong>很像的字符：<code>0x2024</code>。那么这两个Unicode字符在此处就有用武之地了。在网页里，我们可以把foo@bar.com编码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo&amp;#xFF20;BAR&amp;#X2024;com</div></pre></td></tr></table></figure></p>
<p>最终显示效果：<strong>foo&#xFF20;BAR&#X2024;com</strong></p>
<p>很强大有木有！</p>
<p>这种方式也不是完美无缺：</p>
<ul>
<li>如果流行普及了，爬虫会重新设计算法将其也计入探测范围。</li>
<li>使用复制粘贴并非预期文本</li>
</ul>
<p>总之，没有最好，只有最合适的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><p><a href="http://www.csarven.ca/hiding-email-addresses" target="_blank" rel="external">Methods to hide email addresses from page source</a></p>
</li>
<li><p><a href="http://lea.verou.me/2009/11/exploring-browser-supported-unicode-characters-and-a-tweet-shortening-experiment/" target="_blank" rel="external">exploring browser-supported Unicode characters</a></p>
</li>
<li><p><a href="http://lea.verou.me/2009/11/yet-another-email-hiding-technique/" target="_blank" rel="external">Yet another email hiding technique?</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;spambot.jpg&quot; alt=&quot;spam bot&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;我们经常会受到垃圾邮件的骚扰，究其原因，其中主要
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="email" scheme="http://zerosoul.github.io/tags/email/"/>
    
      <category term="技巧" scheme="http://zerosoul.github.io/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="实体字符" scheme="http://zerosoul.github.io/tags/%E5%AE%9E%E4%BD%93%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>老栓买药</title>
    <link href="http://zerosoul.github.io/2016/01/22/evil-with-baidu-connvince/"/>
    <id>http://zerosoul.github.io/2016/01/22/evil-with-baidu-connvince/</id>
    <published>2016-01-22T12:29:32.000Z</published>
    <updated>2016-01-22T12:30:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起早"><a href="#起早" class="headerlink" title="起早"></a>起早</h1><p>深冬的后半夜，月亮下去了，太阳还没有出，只剩下一片冷蓝的天；除了夜游的东西，什么都睡着了。</p>
<p>华老栓忽然坐起，摸索下了床，找到了开关。啪！阴暗的出租屋内便弥满了青白的光。他走到窗边的桌子，滴，破旧的老电脑出现了熟悉的开机界面。</p>
<p>过了两三分钟，他熟练地点开浏览器，首页是刺眼的某度LOGO。</p>
<p>他输入了几个字，进入到某某病的贴吧，点开了一篇图文并茂的帖子，又认真读了一遍，并再三确认了帖子里的评论，拿起了纸，在上面记下了一串数字。</p>
<p>“小栓他爹，这就去么？”</p>
<p>是一个老女人的声音。里边的小黑屋里，也发出一阵咳嗽。</p>
<p>“唔。”</p>
<p>老栓一面听，一面应，一面扣上衣服；伸手过去说，“你给我罢”。</p>
<p>华大妈在枕头底下掏了半天，掏出一张银行卡，交给老栓，老栓接了，抖抖的装入衣袋，又在外面按了两下；便拿上手电筒，关掉灯，走向里屋子去了。</p>
<p>那屋子里面，悉悉窣窣，接着便是一通咳嗽。老栓候他平静下去，才低低的叫道，“小栓……你不要起来。……早饭么？你娘会安排到跟前”。</p>
<h1 id="路上"><a href="#路上" class="headerlink" title="路上"></a>路上</h1><p>老栓听得儿子不再说话，料他安心睡了，便出了门。</p>
<p>走到街上。街上黑沉沉的一无所有，雾霾都分辨不得，只有一条灰白的路，看得分明。电筒光照着他的两脚，一前一后的走。有时也遇到几只流浪狗，可是一只也没有叫。</p>
<p>天气比屋子里冷多了；老栓倒觉爽快，仿佛一旦变了少年，得了神通，有给人生命的本领似的，跨步格外高远。而且路也愈走愈分明，天也愈走愈亮了。</p>
<h1 id="买药"><a href="#买药" class="headerlink" title="买药"></a>买药</h1><p>老栓走到银行门口，停住脚步，想了想，拿起手机拨打了电话。电话接通了，传来不耐烦慵懒的声音。</p>
<p>“谁啊？那么早！”<br>“是我，那个…老栓。我现在就打钱给你们，药什么时候能到？”<br>“哦！”手机里传来的声音瞬间精神起来，“您放心！今天就给您发货！这两天肯定送到您家！”<br>“那药真的管用吗？”<br>“您放心吧！您要不信任我们的话，可以上某度贴吧看看啊！里面有好多吃了我们药后康复的病友发的贴子！您说，要没用的话早就有帖子说我们是假药了不是？这消费者的口碑是做不了假的，您就放一百个心吧！”<br>“哦，不能便宜点吗？为这病家也没剩多少钱了……”<br>“哎呀大叔！我们这药为什么这么贵？就是因为有效果啊！如果卖便宜的话您才需要担心呐！您去某度搜搜这病，首页出来的是不是我们公司的药？为什么？就是因为它效果好啊！如果没有重金投入，怎么出好效果？老实说，要不是您在贴吧咨询过我那么多次，我也了解点您的情况，我怎么可能会给您这么低的价格？”<br>“嗯嗯，我知道了，谢谢你啊。我现在就给你转过去，是这个账号没错吧？”老栓拿出纸条，念出数字。<br>“没错！就这个！我上班后就给您发货！嘿，老爷子，您可够早的，我这儿天还没亮呢……”<br>老栓走到ATM前，插入卡，输入密码，对着纸条一个数字一个数字地输入账号，把钱汇了过去。</p>
<h1 id="回家"><a href="#回家" class="headerlink" title="回家"></a>回家</h1><p>“哎哟老栓这么早出来锻炼？”他走出银行，似乎听得有人问他，但他并不答应；他的精神，现在只在一个包裹上，仿佛那是一个十世单传的婴儿，别的事情，都已置之度外。他现在正等着这个新的生命，移植到家里，收获许多幸福。</p>
<p>天完全亮了，在他面前，显出一条大道；雾霾淹没了一切，路虽宽，却不知尽头。</p>
<p>老栓似乎已习惯了这一切，微笑着望向前方，心里感慨道：这世道真是变了啊。从前遇到疑难杂症问路无门，现在有了某度，一切都方便快捷了。</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>“救星啊！”老栓心里暗自感叹，心里有种似曾相识的感觉，想了很久，“对，我儿子出生那天的感觉！”。</p>
<p>老栓边走边想着病好后的家庭计划，渐渐地，消失在雾霾里…</p>
<p><img src="luxun.jpg" alt="missing luxun"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起早&quot;&gt;&lt;a href=&quot;#起早&quot; class=&quot;headerlink&quot; title=&quot;起早&quot;&gt;&lt;/a&gt;起早&lt;/h1&gt;&lt;p&gt;深冬的后半夜，月亮下去了，太阳还没有出，只剩下一片冷蓝的天；除了夜游的东西，什么都睡着了。&lt;/p&gt;
&lt;p&gt;华老栓忽然坐起，摸索下了床，找到了
    
    </summary>
    
      <category term="随笔" scheme="http://zerosoul.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小说" scheme="http://zerosoul.github.io/tags/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="故事新编" scheme="http://zerosoul.github.io/tags/%E6%95%85%E4%BA%8B%E6%96%B0%E7%BC%96/"/>
    
      <category term="鲁迅" scheme="http://zerosoul.github.io/tags/%E9%B2%81%E8%BF%85/"/>
    
  </entry>
  
  <entry>
    <title>工程师的演讲利器</title>
    <link href="http://zerosoul.github.io/2016/01/16/how-to-ppt/"/>
    <id>http://zerosoul.github.io/2016/01/16/how-to-ppt/</id>
    <published>2016-01-16T07:28:33.000Z</published>
    <updated>2016-01-19T02:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>技术从业者似乎有个普遍的问题：<strong>不擅长表达</strong>。当然，表达方式有多种：写作，作画，舞蹈，甚至摄影，等等。而此处要说的，特指口头表达，也就是演讲。</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>提到演讲，无论是给领导汇报，还是给同事做分享，最好有个PPT做辅助，而这正是干技术的头痛所在：不愿意花时间把PPT做到像市场部那样美轮美奂，认为是浪费时间，最后只是在每一张Slide上放几个词，美名曰“简单即美”，其实是在自欺欺人。</p>
<p>如果你也遇到过类似烦恼，或许下面提到的两个工具能帮助你：</p>
<h2 id="impress-js"><a href="#impress-js" class="headerlink" title="impress.js"></a><a href="http://impress.github.io/impress.js/" target="_blank" rel="external">impress.js</a></h2><p><img src="impress.png" alt="impress.js"></p>
<p>这个神器是我在2014年找工作期间无意间看到的，被官方<a href="http://impress.github.io/impress.js/" target="_blank" rel="external">Demo</a>的效果惊艳到了，果断找来<a href="https://github.com/impress/impress.js/blob/master/js/impress.js" target="_blank" rel="external">源码</a>阅读，研究了一下其中的原理，又发现如此绚丽的效果，用到的技术并不复杂：其核心便是CSS3的Transform和Transition特性。但能把这两个特性运用的如此炉火纯青，歪果仁在利用技术方面，又一次领先了。出于对impress.js的喜爱，当时利用此工具，给自己的做了个<a href="http://zerosoul.github.io/impress-resume/#/landing_page">在线简历</a>。现在看来内容多少有些幼稚，但从浏览体验来说，依然不错。Thank to impress.js!</p>
<p>如果想超赶市场部同事的PPT特效，名副其实的impress.js不会让你失望，相信也会impress到你！</p>
<h2 id="reveal-js"><a href="#reveal-js" class="headerlink" title="reveal.js"></a><a href="http://lab.hakim.se/reveal-js/#/" target="_blank" rel="external">reveal.js</a></h2><p><img src="reveal.png" alt="reveal.js"></p>
<p>这个神器是最近一两周才结识的，也是一见钟情并实战了一次，效果不错。它的特点就是简洁，高大上。impress.js的使用还需要一些坐标计算，reveal.js仅仅需要考虑方向，上下左右，so easy！前两天部门领导要在年度总结大会上做演讲，正发愁怎么做PPT呢，果断不能错过推销神器的机会。在了解领导演讲意图之后，我在impress.js和reveal.js之间选择了reveal.js出马。</p>
<p><img src="ppt.jpg" alt="ppt"></p>
<p>值得一提的是，reveal.js有插件机制，有许多优秀插件可以提高演讲逼格，比如，这次总结大会上用到的<a href="https://github.com/ysmood/notell" target="_blank" rel="external">远程控制插件</a>，乔布斯演讲的即视感有木有！？如果对自己要讲什么已经胸有成竹，做PPT的目的仅仅是为了提示自己讲到哪儿了，该讲哪儿了。那么，reveal.js来干这事儿再适合不过了。</p>
<h1 id="再说两句"><a href="#再说两句" class="headerlink" title="再说两句"></a>再说两句</h1><p>以上只是简单感性地介绍一下两款神器，其实还有很多特性都没有介绍到，等待你去挖掘。不过工具终究是工具，不能代替我们思考。做演讲最重要的还是清楚自己要讲什么：<strong>主题明确，逻辑清晰，没有PPT，同样能达到表达的目的。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;技术从业者似乎有个普遍的问题：&lt;strong&gt;不擅长表达&lt;/strong&gt;。当然，表达方式有多种：写作，作画，舞蹈，甚至摄影，等等。而此处要
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="演讲工具" scheme="http://zerosoul.github.io/tags/%E6%BC%94%E8%AE%B2%E5%B7%A5%E5%85%B7/"/>
    
      <category term="PPT" scheme="http://zerosoul.github.io/tags/PPT/"/>
    
      <category term="impress.js" scheme="http://zerosoul.github.io/tags/impress-js/"/>
    
      <category term="reveal.js" scheme="http://zerosoul.github.io/tags/reveal-js/"/>
    
  </entry>
  
  <entry>
    <title>使用BrowserSync 2.0提高前端开发逼格</title>
    <link href="http://zerosoul.github.io/2016/01/14/Improve-Your-Workflow-With-BrowserSync-2-0/"/>
    <id>http://zerosoul.github.io/2016/01/14/Improve-Your-Workflow-With-BrowserSync-2-0/</id>
    <published>2016-01-14T02:54:18.000Z</published>
    <updated>2016-01-14T07:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Web开发，尤其是前端开发，经常要做的就是不停地“试错”。下面的场景你是否熟悉：</p>
<p>1.在浏览器打开网页<br>2.更改一两行代码<br>3.点击浏览器的刷新，重复 <strong>步骤2</strong></p>
<p>周而复始，还要在不同的设备，不同的浏览器，不同的测试方法，Oh God，编码本来是一项充满创造性的工作，为何如此苦逼？</p>
<h1 id="希望"><a href="#希望" class="headerlink" title="希望"></a>希望</h1><p>程序员应该养成一个优秀习惯：当意识到有重复性的动作，反思一下能不能交给机器来做？有关上面提到的不停地“试错”，其实早就有了解决方式：BrowserSync。我比较懒，懒到人家都出2.0了，才开始了解与使用。</p>
<blockquote>
<p>好工具从来不会缺席，只是有时候会迟到。   – 尼古拉斯•杨二</p>
</blockquote>
<p>让我们先来看一下新版本有哪些特性：</p>
<h2 id="实时刷新-Live-reloading"><a href="#实时刷新-Live-reloading" class="headerlink" title="实时刷新 (Live reloading)"></a>实时刷新 (Live reloading)</h2><p>这个应该是基本的吧。修改某个文件（html,css,js），会自动刷新你所打开的所有浏览页面，对，也包括手机端的，这个挺酷的。</p>
<h2 id="交互同步-Interaction-synchronization"><a href="#交互同步-Interaction-synchronization" class="headerlink" title="交互同步(Interaction synchronization)"></a>交互同步(Interaction synchronization)</h2><p>一句话概括就是：镜像你的交互。滚动页面，点击，表单操作等等会被同步到每个你打开的浏览器。这招在调试移动端页面相当有用，都知道在手机输入文字的痛苦，尤其是英文，有了它，妈妈再也不会看到你拿着手机打字纠结的表情了：完全可以在PC上相应文本框输入文本，然后会同步到每个关联的移动设备上，Amazing！除此之外，你还可以选择哪些交互可以被镜像，真贴心！</p>
<h2 id="远程调试-Remote-inspector"><a href="#远程调试-Remote-inspector" class="headerlink" title="远程调试(Remote inspector)"></a>远程调试(Remote inspector)</h2><p>可以使用类似谷歌的 <a href="https://developer.chrome.com/devtools" target="_blank" rel="external">Dev Tools</a> 来远程调试页面。</p>
<p><img src="browsersync2-weinre.png" alt=""></p>
<h2 id="模拟网速-Simulate-slower-connections"><a href="#模拟网速-Simulate-slower-connections" class="headerlink" title="模拟网速(Simulate slower connections)"></a>模拟网速(Simulate slower connections)</h2><p>Dev Tools 里面已有这个功能，相当实用的一个功能，有些开发问题只有在网速慢的情况才好复现。看来，优秀的工具总是能戳中使用者的痛点。</p>
<h2 id="记录浏览历史-URL-history"><a href="#记录浏览历史-URL-history" class="headerlink" title="记录浏览历史(URL history)"></a>记录浏览历史(URL history)</h2><p>浏览历史被记录的好处就是可以随时推送某个测试网址到所有设备，免去记忆和输入的成本，相当便捷。</p>
<h2 id="新UI！-New-UI"><a href="#新UI！-New-UI" class="headerlink" title="新UI！(New UI)"></a>新UI！(New UI)</h2><p>如果不习惯命令行控制方式，可以使用基于网页的UI管理。</p>
<p><img src="browsersync2-gui.png" alt=""></p>
<h2 id="兼容构建工具-Build-tool-compatibility"><a href="#兼容构建工具-Build-tool-compatibility" class="headerlink" title="兼容构建工具(Build-tool compatibility)"></a>兼容构建工具(Build-tool compatibility)</h2><p>可以和Gulp,Grunt以及其它构建工具配套使用。<br><strong>注：这个特性我还没有尝试，不过看起来很高级很好玩的样子。</strong></p>
<h2 id="下载即用！-Install-anywhere-for-free"><a href="#下载即用！-Install-anywhere-for-free" class="headerlink" title="下载即用！(Install anywhere for free)"></a>下载即用！(Install anywhere for free)</h2><p>BrowserSync是开源作品，并且支持Windows, Mac OS and Linux三大操作平台。不需要安装浏览器插件或者其他软件，妈妈再也不用担心乱装东西啦。</p>
<h1 id="BrowserSync-是怎样的工作原理"><a href="#BrowserSync-是怎样的工作原理" class="headerlink" title="BrowserSync 是怎样的工作原理"></a>BrowserSync 是怎样的工作原理</h1><p>启用BrowserSync时，会建立一个小型web服务器。如果本地存在一个web服务器或者需要与一个线上网站建立联系，可以将BrowserSync当做一个代理服务器。它将在每个访问的页面注入一小段js代码，并使用 <a href="https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference" target="_blank" rel="external"><strong>websocket</strong></a>与服务器通信。当有事件触发时，比如更改了某个文件或者触发了滚动操作，服务端便会向所有的连接设备发送更新。</p>
<p>如果你的定位是使用而非参与开发BrowserSync，了解到这里就足够啦。</p>
<h1 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h1><p>那么…如何安装呢？有个前提条件：安装<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a>。</p>
<p>命令行执行<code>node -v</code>，确保Node安装OK。</p>
<p>全局安装BrowserSync:<code>npm install browser-sync -g</code></p>
<p>注：我在Mac下遇到个问题，需要在npm前面加<code>sudo</code>，才能执行成功，应该跟本人的环境配置有关。</p>
<p>测试安装OK与否：<code>browser-sync --version</code></p>
<p>看看BrowserSync下有哪些命令可以使用：<code>browser-sync --help</code></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>举个例子：<br>假设有个<code>test</code>文件夹，里面有HTML文件和css文件夹，css文件夹里面当然是css文件啦。<br>首先，先跑到<code>test</code>文件夹下：<code>cd test</code></p>
<p>然后 BrowserSync 之：<code>browser-sync start --server --files &quot;*.html, css/*.css&quot;</code></p>
<p>随后将启用一个小型服务器，并监听test下的所有html和css文件夹下的css文件。此时此刻，命令行界面应该显示类似这样的一列信息：</p>
<p><pre></pre></p>
<pre><code>[BS] Access URLs:
 -------------------------------------
       Local: http://localhost:3000
    External: http://192.168.1.21:3000
 -------------------------------------
          UI: http://localhost:3001
 UI External: http://192.168.1.21:3001
 -------------------------------------
[BS] Serving files from: ./
[BS] Watching files...
</code></pre><p><br><code>External</code>表示在同一网段下的所有设备都可以访问这个地址。<code>UI</code>的意思就是网页版的控制中心。</p>
<p>还有许多其它特性可以从命令行挖掘。总而言之，花上一两个小时来体验一下，相信你从今以后会离不开它！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.browsersync.io/" target="_blank" rel="external">BrowserSync官网</a><br><a href="http://www.browsersync.io/docs/command-line/" target="_blank" rel="external">BrowserSync文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;Web开发，尤其是前端开发，经常要做的就是不停地“试错”。下面的场景你是否熟悉：&lt;/p&gt;
&lt;p&gt;1.在浏览器打开网页&lt;br&gt;2.更改一两行代
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发" scheme="http://zerosoul.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="工具" scheme="http://zerosoul.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="BrowserSync" scheme="http://zerosoul.github.io/tags/BrowserSync/"/>
    
  </entry>
  
  <entry>
    <title>杨二小</title>
    <link href="http://zerosoul.github.io/2015/12/20/about-2016/"/>
    <id>http://zerosoul.github.io/2015/12/20/about-2016/</id>
    <published>2015-12-20T12:36:58.000Z</published>
    <updated>2016-01-19T02:44:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>生命是场持续而长久的积累，没有人真正在乎你在何时，在何地，是在烧着脑细胞，还是在洒着汗水。人们往往只是在你惊艳众人那一刻惊呼：卧槽，这么牛X怎么做到的？！甚至没有仔细听你解释是如何做到的，就去猎奇下一个惊艳时刻。所以，没那么多观众，放轻松，别活得太累。偶尔遇到愿意听你说到口干舌燥的，别犹豫，那不是友情便是爱情。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>去年此时，我大概在构思今年要做的事情，并有意地把其中<a href="http://zerosoul.github.io/2015/02/01/against-the-flow/">十件事</a>以博文的形式暴露出来，其目的是为了形成某种监督，进而对自己有所激励。此时此刻，恰好一年，这种方式目前来看是有效果的，所以没有理由不沿用一下。</p>
<ol>
<li><p>每月写博文<br>忙碌不是逃避思考的借口，恰恰是应该坐下来想一下：为什么这么忙？以前常常有想法，却没有以文字的方式沉淀下来，我觉得是种浪费，效率上的浪费，因为能把思考写出来才有生根发芽的可能性，好记性不如烂博文。一篇技术，一点译文，一篇随笔，或者读书笔记都行，每月至少两篇吧。一年下来24篇，恩，不能再少了。</p>
</li>
<li><p>物尽其用<br>这里的“物”，主要指的是我的MAC本。MAC除了用来装X，对于开发人员更重要的是提高效率，目前我还没有完全适应使用MAC工作，所以物尽其用还有距离呢。当然，工具终究是工具，更重要的是想法，两条腿走路，更稳当一些。</p>
</li>
<li><p>APP<br>在技术行业工作了几年，耳濡目染久了，也有了互联网产品情节。所以想凭一己之力做个能解决个人具体需求的APP产品，由于自己是干前端的，自然而然的就想到了以前端方式来做。这个过程应该是个学习与实践的好机会，恩，好好玩。</p>
</li>
<li><p>塑身<br>今年跑步坚持的还不错，身材也相应地变好了一些，但距离“好身材”还略远。所以借着今年打下的底子，继续坚持跑步的同时，办个健身卡，有条件就再请个私教，制定科学的健身计划，持之以恒。虽然走的是健身流程，但最终目的还是想打造完美的身材协调比例，比如肩膀匀不匀称，小腿粗不粗壮，挺胸抬头，全身看上去很协调，就算OK。总之，“主要看气质”，这也是我用的是“塑身”一词，而不是“健身”的原因，至于胸肌，腹肌，肱二头肌发不发达，恩，全是赠品。</p>
</li>
<li><p>环台湾岛骑行<br>本来计划在今年春节期间去，种种原因拖延到现在，已经来不及了，推到下一年年底吧。或许还是一个人，或许是两人，恩，不能再多了…</p>
</li>
<li><p>阅读<br>听说能让人保持创造力的最好方式便是持续地阅读，如果说今年的阅读是为了广度，那么明年便是着重深度。不求多，但求精，速度不快，一两个月啃下一本足矣，附带读书笔记。So… 10本书吧，不能再多了，再多就醉了。</p>
</li>
<li><p>再去一次怀化某山村<br>今年10月份去了次，山清水秀，民风淳朴，与那里结下了更为深厚的不解之缘。从今年开始，每年都会去一次。</p>
</li>
<li><p>英语进阶<br>英语一直是半瓶子醋水平，虽说应付工作日常足矣，但作为一种开阔视野的好工具，谁不想更为全面地掌握呢。打算通过翻译一本书做起，也算是给“阅读”和“博文”做贡献。</p>
</li>
<li><p>摄影进阶<br>摄影是个烧钱的爱好，我不是器材党，所以目前来看，总投资没超过5K，都不好意思说自己喜欢摄影了。所谓的进阶，可能更多的是片子的后期。另，入手一个广角镜头，恩，不能再多了。</p>
</li>
<li><p>学一种乐器<br>说来惭愧，曾经有学吉他的冲动，但也就止于冲动了。吉他携带有些不方便，我更习惯低调，所以想到了口琴，恩，练练口活。</p>
</li>
</ol>
<p>还是那个意思：10件事不是目标，也不是梦想，只是10件事。有些需要常做，比如塑身，有些是一次性，比如骑行，有些烧脑，有些烧钱，有些流汗，甚至有些流泪。不管怎样，都需要努力。努力不是一场真人秀，更像是在做幕后，在看不到的时间与空间持续付出着…</p>
<p>至于梦想，我觉得其实是一个很平常的东西，那句话怎么说的来着：梦想就像内裤，你得有，但是不要经常拿出来炫耀。从不觉得一个人为了梦想付出很多就显得很高尚。每个人都有自己的生活方式，没有梦想或者不愿意为梦想付出的人也值得尊重，毕竟做成一件事有时不是靠实力，还有运气。</p>
<p>“内裤”就不晒了，不过做完以上10件事，梦想应该是更近了一步，更何况明年不止这10件。</p>
<p>努力成为自己想成为的人，不明不白盲目努力的生活，不值得一过。</p>
<p><img src="about-2016.jpg" alt="carrying man"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;楔子&quot;&gt;&lt;a href=&quot;#楔子&quot; class=&quot;headerlink&quot; title=&quot;楔子&quot;&gt;&lt;/a&gt;楔子&lt;/h1&gt;&lt;p&gt;生命是场持续而长久的积累，没有人真正在乎你在何时，在何地，是在烧着脑细胞，还是在洒着汗水。人们往往只是在你惊艳众人那一刻惊呼：卧槽，这么牛X
    
    </summary>
    
      <category term="随笔" scheme="http://zerosoul.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="坚持" scheme="http://zerosoul.github.io/tags/%E5%9D%9A%E6%8C%81/"/>
    
      <category term="计划" scheme="http://zerosoul.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="年终总结" scheme="http://zerosoul.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>科学地使用 Hexo 和 Github Pages 装X</title>
    <link href="http://zerosoul.github.io/2015/11/05/build-personal-site-with-hexo-and-github-pages/"/>
    <id>http://zerosoul.github.io/2015/11/05/build-personal-site-with-hexo-and-github-pages/</id>
    <published>2015-11-05T12:35:22.000Z</published>
    <updated>2016-01-19T02:44:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a><a href="http://github.com" target="_blank" rel="external">Github</a></h2><ol>
<li>登陆你的Github</li>
<li>新建一个Repository</li>
<li>将之命名为<em>yourGithubName.github.io</em>(注意替换yourGithubName)</li>
<li>关键步骤已经完成，其他选项随意啦。点击新建后，别忘了把<em>SSH</em>的地址copy一份，后面有用到</li>
</ol>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a><a href="http://hexo.io" target="_blank" rel="external">Hexo</a></h2><ol>
<li>打开终端</li>
<li>Hexo依赖 Node 环境，如果没有先安装 Node &amp; npm，参考<a href="http://nodejs.org" target="_blank" rel="external">官网</a></li>
<li>安装 Hexo<br><code>npm install -g hexo</code></li>
<li>齐活，Hexo准备完毕</li>
</ol>
<h1 id="开始使用Hexo撸Github需要的东西"><a href="#开始使用Hexo撸Github需要的东西" class="headerlink" title="开始使用Hexo撸Github需要的东西"></a>开始使用Hexo撸Github需要的东西</h1><ol>
<li>进入到你想放置github pages repository的目录</li>
<li>在此创建Hexo Project<br><code>hexo init yourGithubName.github.io</code></li>
<li>切换到刚刚创建的目录<br><code>cd yourGithubName.github.io</code></li>
<li>安装依赖&amp;生成静态文件&amp;启动本地服务器<br><code>npm install &amp; hexo g &amp; hexo s</code></li>
<li>目测现在就可以通过访问localhost:4000来瞅瞅网站啥样了</li>
</ol>
<h1 id="部署到Github上"><a href="#部署到Github上" class="headerlink" title="部署到Github上"></a>部署到Github上</h1><ol>
<li>首先，停掉Hexo <code>Control + C</code></li>
<li>打开根目录的_config.yml，设置Github地址<br><code>deploy:
 type: git
 repo: git@github.com:yourGithubName/yourGithubName.github.io.git</code></li>
<li>部署前，先确认有没有安装<em><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="external">hexo-deployer-git</a></em><br><code>npm install hexo-deployer-git --save</code></li>
<li>部署<br><code>hexo d</code></li>
<li>打开浏览器，访问 <em>yourGithubName.github.io</em></li>
</ol>
<h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><ol>
<li>使用Markdown写作，完事后保存到source/_posts/</li>
<li>重新生成静态文件<br><code>hexo g</code></li>
<li>运行<code>hexo s</code>在本地查看刚刚写的文章</li>
<li>木问题的话，更新至Github<br><code>hexo d</code></li>
</ol>
<h1 id="绑定自己的域名"><a href="#绑定自己的域名" class="headerlink" title="绑定自己的域名"></a>绑定自己的域名</h1><blockquote>
<p>我通过淘宝代理<a href="https://www.godaddy.com/" target="_blank" rel="external">Godaddy</a>购买了 <a href="http://zerosou.us" target="_blank" rel="external">zerosoul.github.io</a> 域名，就拿这个举例如何绑定吧</p>
</blockquote>
<ol>
<li>Github上进入 zerosoul.github.io</li>
<li>创建并提交CNAME文件，里面只有一行内容，就是域名：<code>zerosoul.github.io</code></li>
<li>去Godaddy网站管理域名页面<br><img src="godaddy_setting.jpg" alt="godaddy setting"></li>
<li>增加一条 A 记录:host=<code>@</code>，Points to=<code>192.30.252.153</code></li>
<li>增加一条 CNAME 记录:host=<code>www</code>，Points to=<code>zerosoul.github.io</code></li>
<li>最后，一定要记得保存更改！<br><img src="godaddy_saving.jpg" alt="godaddy saving"></li>
<li>静待更改生效，大概一两个小时。</li>
</ol>
<h1 id="两个小时后…"><a href="#两个小时后…" class="headerlink" title="两个小时后…"></a>两个小时后…</h1><p><strong>装X成功！</strong></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://hexo.io/docs/" target="_blank" rel="external">hexo doc</a><br><a href="https://help.github.com/categories/github-pages-basics/" target="_blank" rel="external">github pages basic</a><br><a href="http://andrewsturges.com/blog/jekyll/tutorial/2014/11/06/github-and-godaddy.html" target="_blank" rel="external">Configuring a Godaddy domain name with github pages</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;h2 id=&quot;Github&quot;&gt;&lt;a href=&quot;#Github&quot; class=&quot;headerlink&quot; title=&quot;Githu
    
    </summary>
    
      <category term="技术" scheme="http://zerosoul.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="github" scheme="http://zerosoul.github.io/tags/github/"/>
    
      <category term="hexo" scheme="http://zerosoul.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://zerosoul.github.io/tags/blog/"/>
    
      <category term="nodejs" scheme="http://zerosoul.github.io/tags/nodejs/"/>
    
  </entry>
  
</feed>
